<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ComplexityAnalysis.Solver</name>
    </assembly>
    <members>
        <member name="T:ComplexityAnalysis.Solver.IntegralEvaluationResult">
            <summary>
            Result of evaluating the Akra-Bazzi integral.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.IntegralEvaluationResult.Success">
            <summary>Whether the integral could be evaluated (closed-form or symbolic).</summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.IntegralEvaluationResult.IntegralTerm">
            <summary>
            The asymptotic form of the integral term.
            For Akra-Bazzi: Θ(n^p · (1 + ∫₁ⁿ g(u)/u^(p+1) du))
            This captures the integral contribution.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.IntegralEvaluationResult.FullSolution">
            <summary>
            The complete Akra-Bazzi solution combining n^p with the integral.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.IntegralEvaluationResult.Explanation">
            <summary>Human-readable explanation of the evaluation.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.IntegralEvaluationResult.Confidence">
            <summary>Confidence in the result (0.0 to 1.0).</summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.IntegralEvaluationResult.IsSymbolic">
            <summary>Whether the result is symbolic (requires further refinement).</summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.IntegralEvaluationResult.SpecialFunction">
            <summary>Special function type if applicable.</summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.SpecialFunctionType">
            <summary>
            Types of special functions that may arise in integral evaluation.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.SpecialFunctionType.Polylogarithm">
            <summary>Polylogarithm Li_s(z)</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.SpecialFunctionType.IncompleteGamma">
            <summary>Incomplete gamma function γ(s, x)</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.SpecialFunctionType.IncompleteBeta">
            <summary>Incomplete beta function B(x; a, b)</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.SpecialFunctionType.Hypergeometric2F1">
            <summary>Gauss hypergeometric ₂F₁(a, b; c; z)</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.SpecialFunctionType.SymbolicIntegral">
            <summary>Deferred symbolic integral</summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.IAkraBazziIntegralEvaluator">
             <summary>
             Evaluates the integral term in the Akra-Bazzi theorem.
            
             Akra-Bazzi solution: T(n) = Θ(n^p · (1 + ∫₁ⁿ g(u)/u^(p+1) du))
            
             For common g(u) forms, this integral has closed-form solutions:
            
             | g(n)           | k vs p    | Integral Result          | Full Solution        |
             |----------------|-----------|--------------------------|----------------------|
             | n^k            | k &lt; p     | O(1)                     | Θ(n^p)               |
             | n^k            | k = p     | O(log n)                 | Θ(n^p · log n)       |
             | n^k            | k > p     | O(n^(k-p))               | Θ(n^k)               |
             | n^k · log^j n  | k &lt; p     | O(1)                     | Θ(n^p)               |
             | n^k · log^j n  | k = p     | O(log^(j+1) n)           | Θ(n^p · log^(j+1) n) |
             | n^k · log^j n  | k > p     | O(n^(k-p) · log^j n)     | Θ(n^k · log^j n)     |
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.IAkraBazziIntegralEvaluator.Evaluate(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
            <summary>
            Evaluates the Akra-Bazzi integral for the given g(n) and critical exponent p.
            </summary>
            <param name="g">The non-recursive work function g(n).</param>
            <param name="variable">The variable (typically n).</param>
            <param name="p">The critical exponent satisfying Σᵢ aᵢ · bᵢ^p = 1.</param>
            <returns>The evaluation result with the full solution.</returns>
        </member>
        <member name="T:ComplexityAnalysis.Solver.TableDrivenIntegralEvaluator">
             <summary>
             Table-driven implementation for common integral forms with special function fallback.
            
             Handles standard cases with closed forms and falls back to special functions
             (hypergeometric, polylogarithm, gamma, beta) or symbolic integrals for
             complex cases that require later refinement.
             </summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.TableDrivenIntegralEvaluator.Tolerance">
            <summary>Tolerance for comparing k to p.</summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.TableDrivenIntegralEvaluator.EvaluateExponential(ComplexityAnalysis.Core.Complexity.ExpressionClassification,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
             <summary>
             g(n) = c · b^n (exponential)
             ∫₁ⁿ b^u / u^(p+1) du
            
             This integral relates to the incomplete gamma function when transformed.
             For b > 1 and large n, the exponential dominates.
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.TableDrivenIntegralEvaluator.EvaluateGeneric(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
            <summary>
            Generic fallback for unrecognized g(n) forms.
            Creates a symbolic integral with asymptotic bounds estimated heuristically.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.TableDrivenIntegralEvaluator.EvaluateConstant(ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
             <summary>
             g(n) = c (constant)
             ∫₁ⁿ c/u^(p+1) du = c · [-1/(p·u^p)]₁ⁿ = c/p · (1 - 1/n^p)
            
             For p > 0: this is O(1), so solution is Θ(n^p)
             For p = 0: ∫₁ⁿ c/u du = c · log(n), so solution is Θ(log n)
             For p &lt; 0: this grows, dominated by n^(-p) term
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.TableDrivenIntegralEvaluator.EvaluatePolynomial(ComplexityAnalysis.Core.Complexity.ExpressionClassification,ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
             <summary>
             g(n) = n^k (pure polynomial)
             ∫₁ⁿ u^k/u^(p+1) du = ∫₁ⁿ u^(k-p-1) du
            
             If k - p - 1 = -1 (i.e., k = p): ∫ du/u = log(n)
             If k - p - 1 ≠ -1: [u^(k-p)/(k-p)]₁ⁿ = (n^(k-p) - 1)/(k-p)
               - If k &lt; p: this is O(1)
               - If k > p: this is O(n^(k-p))
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.TableDrivenIntegralEvaluator.EvaluateLogarithmic(ComplexityAnalysis.Core.Complexity.ExpressionClassification,ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
            <summary>
            g(n) = log^j(n) (pure logarithmic, k = 0)
            This is a special case of polylog with k = 0.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.TableDrivenIntegralEvaluator.EvaluatePolyLog(ComplexityAnalysis.Core.Complexity.ExpressionClassification,ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
             <summary>
             g(n) = n^k · log^j(n) (polylogarithmic)
             ∫₁ⁿ u^k · log^j(u) / u^(p+1) du = ∫₁ⁿ u^(k-p-1) · log^j(u) du
            
             Case k = p: ∫ log^j(u)/u du = log^(j+1)(n)/(j+1)
             Case k &lt; p: Integral converges to O(1)
             Case k > p: Integral ~ n^(k-p) · log^j(n)
             </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.ExtendedIntegralEvaluator">
             <summary>
             Extended integral evaluator with hypergeometric and special function support.
            
             This evaluator handles more complex g(n) forms that require special functions:
             - Fractional polynomial exponents → Hypergeometric ₂F₁
             - Products/ratios of polynomials → Beta functions
             - Exponential-polynomial products → Incomplete gamma
             - Iterated logarithms → Polylogarithm
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.ExtendedIntegralEvaluator.TryFractionalPolynomial(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
             <summary>
             g(n) = n^k where k is not an integer (fractional exponents).
             ∫₁ⁿ u^(k-p-1) du = [u^(k-p) / (k-p)]₁ⁿ when k ≠ p
            
             Still elementary, but we ensure numerical stability for non-integer exponents.
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.ExtendedIntegralEvaluator.TryPolynomialRatio(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
            <summary>
            g(n) = n^a / (1 + n^b)^c - polynomial ratio forms
            These lead to Beta/hypergeometric functions via substitution u = n^b / (1 + n^b)
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.ExtendedIntegralEvaluator.TryIteratedLogarithm(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
            <summary>
            g(n) = log(log(n))^j - iterated logarithms
            These arise in algorithms with deep recursive structures.
            Integral: ∫ log(log(u))^j / u^(p+1) du involves polylogarithms.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.ExtendedIntegralEvaluator.TryProductForm(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
            <summary>
            g(n) = f₁(n) · f₂(n) - product forms
            Try to decompose and evaluate based on dominant factor.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.ExtendedIntegralEvaluator.CreateSymbolicWithHeuristic(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
            <summary>
            Creates a symbolic integral with heuristic asymptotic bounds.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.SymPyIntegralEvaluator">
             <summary>
             SymPy-based integral evaluator that calls Python subprocess for symbolic computation.
            
             Uses SymPy's powerful symbolic integration engine to evaluate arbitrary g(n):
             ∫₁ⁿ g(u)/u^(p+1) du
            
             Falls back to table-driven evaluation for common cases, using SymPy only
             when the expression form is complex or unknown.
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.SymPyIntegralEvaluator.EvaluateWithSymPyAsync(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,System.Double,System.Threading.CancellationToken)">
            <summary>
            Evaluates the integral using SymPy asynchronously.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.SymPyIntegralEvaluator.ToSymPyString(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Converts a ComplexityExpression to a SymPy-parseable string.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.SymPyIntegralEvaluator.ParseComplexityFromSymPy(System.String,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Parses a SymPy complexity string back into a ComplexityExpression.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.ICriticalExponentSolver">
            <summary>
            Solves for the critical exponent p in Akra-Bazzi theorem.
            Uses MathNet.Numerics for root finding.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.ICriticalExponentSolver.Solve(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.Double,System.Double}},System.Double,System.Int32)">
            <summary>
            Solves Σᵢ aᵢ · bᵢ^p = 1 for p.
            </summary>
            <param name="terms">The (aᵢ, bᵢ) pairs from the recurrence.</param>
            <param name="tolerance">Convergence tolerance.</param>
            <param name="maxIterations">Maximum iterations for root finding.</param>
            <returns>The critical exponent p, or null if no solution found.</returns>
        </member>
        <member name="M:ComplexityAnalysis.Solver.ICriticalExponentSolver.EvaluateSum(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.Double,System.Double}},System.Double)">
            <summary>
            Evaluates Σᵢ aᵢ · bᵢ^p for a given p.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.ICriticalExponentSolver.EvaluateDerivative(System.Collections.Generic.IReadOnlyList{System.ValueTuple{System.Double,System.Double}},System.Double)">
            <summary>
            Evaluates the derivative d/dp[Σᵢ aᵢ · bᵢ^p] = Σᵢ aᵢ · bᵢ^p · ln(bᵢ).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.MathNetCriticalExponentSolver">
            <summary>
            Standard implementation using MathNet.Numerics root finding.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.KnownCriticalExponents">
            <summary>
            Known solutions for common recurrence patterns.
            Used for verification and optimization.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.KnownCriticalExponents.MasterTheorem(System.Double,System.Double)">
            <summary>
            For T(n) = aT(n/b) + f(n): p = log_b(a).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.KnownCriticalExponents.BinaryDivideAndConquer">
            <summary>
            For T(n) = 2T(n/2) + f(n): p = 1.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.KnownCriticalExponents.BinarySearch">
            <summary>
            For T(n) = T(n/2) + f(n): p = 0.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.KnownCriticalExponents.Karatsuba">
            <summary>
            For T(n) = 3T(n/2) + f(n): p = log_2(3) ≈ 1.585.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.KnownCriticalExponents.Strassen">
            <summary>
            For T(n) = 7T(n/2) + f(n): p = log_2(7) ≈ 2.807 (Strassen).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.LinearRecurrenceSolver">
            <summary>
            Solves linear recurrence relations using the characteristic polynomial method.
            </summary>
            <remarks>
            <para>
            <b>Problem Form:</b> T(n) = a₁T(n-1) + a₂T(n-2) + ... + aₖT(n-k) + f(n)
            </para>
            
            <para>
            <b>Solution Algorithm:</b>
            </para>
            <list type="number">
              <item><description>
                <b>Characteristic Polynomial:</b> Form p(x) = x^k - a₁x^(k-1) - ... - aₖ
              </description></item>
              <item><description>
                <b>Root Finding:</b> Find all roots using companion matrix eigendecomposition
              </description></item>
              <item><description>
                <b>Homogeneous Solution:</b> Build from roots with multiplicities
              </description></item>
              <item><description>
                <b>Particular Solution:</b> Handle non-homogeneous term f(n)
              </description></item>
              <item><description>
                <b>Asymptotic Form:</b> Extract dominant term for Big-O notation
              </description></item>
            </list>
            
            <para>
            <b>Root Types and Their Contributions:</b>
            </para>
            <list type="table">
              <listheader>
                <term>Root Type</term>
                <description>Contribution to Solution</description>
              </listheader>
              <item>
                <term>Real root r (simple)</term>
                <description>c·rⁿ</description>
              </item>
              <item>
                <term>Real root r (multiplicity m)</term>
                <description>(c₀ + c₁n + ... + c_{m-1}n^{m-1})·rⁿ</description>
              </item>
              <item>
                <term>Complex pair α±βi</term>
                <description>ρⁿ(c₁cos(nθ) + c₂sin(nθ)) where ρ = √(α²+β²)</description>
              </item>
            </list>
            
            <para>
            <b>Common Solutions:</b>
            </para>
            <code>
            // T(n) = T(n-1) + 1 → O(n)
            // T(n) = T(n-1) + n → O(n²)
            // T(n) = 2T(n-1) + 1 → O(2ⁿ)
            // T(n) = T(n-1) + T(n-2) → O(φⁿ) ≈ O(1.618ⁿ)
            // T(n) = 4T(n-1) - 4T(n-2) → O(n·2ⁿ) (repeated root)
            </code>
            </remarks>
        </member>
        <member name="F:ComplexityAnalysis.Solver.LinearRecurrenceSolver.Epsilon">
            <summary>Tolerance for root comparison and numerical stability.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.LinearRecurrenceSolver.RootEqualityTolerance">
            <summary>Tolerance for considering roots equal (for multiplicity detection).</summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.LinearRecurrenceSolver.Instance">
            <summary>
            Default singleton instance.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.LinearRecurrenceSolver.Solve(ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation)">
            <summary>
            Solves a linear recurrence relation and returns the asymptotic complexity.
            </summary>
            <param name="recurrence">The linear recurrence to solve.</param>
            <returns>The solution, or null if the recurrence cannot be solved.</returns>
        </member>
        <member name="M:ComplexityAnalysis.Solver.LinearRecurrenceSolver.SolveSummation(ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation)">
            <summary>
            Solves a simple summation recurrence T(n) = T(n-1) + f(n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.LinearRecurrenceSolver.FindCharacteristicRoots(System.Collections.Immutable.ImmutableArray{System.Double})">
            <summary>
            Finds the roots of the characteristic polynomial using companion matrix eigendecomposition.
            </summary>
            <remarks>
            For a recurrence T(n) = a₁T(n-1) + a₂T(n-2) + ... + aₖT(n-k),
            the characteristic polynomial is: x^k - a₁x^(k-1) - a₂x^(k-2) - ... - aₖ = 0
            
            We find roots by computing eigenvalues of the companion matrix.
            </remarks>
        </member>
        <member name="M:ComplexityAnalysis.Solver.LinearRecurrenceSolver.SolveQuadratic(System.Double,System.Double)">
            <summary>
            Solves a quadratic characteristic equation: x² - a₁x - a₂ = 0.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.LinearRecurrenceSolver.SolveUsingCompanionMatrix(System.Collections.Immutable.ImmutableArray{System.Double})">
            <summary>
            Solves a characteristic equation using companion matrix eigendecomposition.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.LinearRecurrenceSolver.GroupRootsByMultiplicity(System.Collections.Immutable.ImmutableArray{ComplexityAnalysis.Core.Recurrence.CharacteristicRoot})">
            <summary>
            Groups roots by value and determines multiplicities.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.LinearRecurrenceSolver.BuildHomogeneousSolution(ComplexityAnalysis.Core.Recurrence.CharacteristicRoot,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Builds the asymptotic solution from the dominant root.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.LinearRecurrenceSolver.CombineWithParticular(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Recurrence.CharacteristicRoot,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Combines homogeneous solution with particular solution for non-homogeneous term.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.LinearRecurrenceSolver.CompareAndTakeMax(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Compares two complexities and returns the asymptotically larger one.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.ILinearRecurrenceSolver">
            <summary>
            Interface for linear recurrence solvers.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.ILinearRecurrenceSolver.Solve(ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation)">
            <summary>
            Solves a linear recurrence relation.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.CharacteristicPolynomialSolved">
            <summary>
            Theorem applicability result for linear recurrences solved by characteristic polynomial.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.CharacteristicPolynomialSolved.#ctor(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Recurrence.LinearRecurrenceSolution)">
            <summary>
            Theorem applicability result for linear recurrences solved by characteristic polynomial.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.MutualRecurrenceSolver">
            <summary>
            Solves mutual recursion systems by converting them to equivalent single recurrences.
            
            Key insight: A mutual recursion cycle A → B → C → A can be "unrolled" to a single
            recurrence by substitution. If each step reduces by 1:
              A(n) calls B(n-1), B(n) calls C(n-1), C(n) calls A(n-1)
              Combined: A(n) = f_A + f_B + f_C + A(n-3)
              This is T(n) = T(n-k) + g(n) where k = cycle length
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.MutualRecurrenceSolver.Solve(ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSystem)">
            <summary>
            Solves a mutual recursion system.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.MutualRecurrenceSolver.SolveSubtractionPattern(ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSystem,ComplexityAnalysis.Core.Recurrence.RecurrenceRelation)">
            <summary>
            Solves subtraction-based mutual recursion: A(n) → B(n-1) → C(n-1) → A(n-1)
            
            For cycle of length k with each step reducing by 1:
            T(n) = T(n-k) + g(n) where g(n) is combined work
            
            This sums to: T(n) = Σᵢ g(n - i*k) + T(base) for i from 0 to n/k
            Approximately: T(n) = (n/k) * g(n) = Θ(n * g(n) / k) = Θ(n * g(n))
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.MutualRecurrenceSolver.SolveDivisionPattern(ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSystem,ComplexityAnalysis.Core.Recurrence.RecurrenceRelation)">
            <summary>
            Solves division-based mutual recursion: A(n) → B(n/2) → C(n/2) → A(n/2)
            
            For cycle of length k with each step dividing by b:
            Combined scale factor: b^k (e.g., if k=3 and b=2, scale = 1/8)
            
            Use standard theorem solving on the combined recurrence.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.MutualRecurrenceSolver.SolveMixedPattern(ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSystem,ComplexityAnalysis.Core.Recurrence.RecurrenceRelation)">
            <summary>
            Handles mixed patterns where methods use different reduction strategies.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.MutualRecurrenceSolver.SolveByHeuristic(ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSystem,ComplexityAnalysis.Core.Recurrence.RecurrenceRelation)">
            <summary>
            Heuristic solver when standard theorems don't apply.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.MutualRecurrenceSolverExtensions">
            <summary>
            Extension methods for mutual recursion solving.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.MutualRecurrenceSolverExtensions.Solve(ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSystem)">
            <summary>
            Solves a mutual recurrence system using the default solver.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.ConfidenceScorer">
            <summary>
            Computes confidence scores for complexity analysis results.
            Takes into account multiple factors including:
            - Source of the analysis (theoretical vs numerical)
            - Verification results
            - Stability of numerical fits
            - Theorem applicability
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.Refinement.ConfidenceScorer.SourceWeights">
            <summary>Base confidence weights for different analysis sources.</summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.ConfidenceScorer.ComputeConfidence(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Solver.Refinement.AnalysisContext)">
            <summary>
            Computes an overall confidence score for a complexity result.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.ConfidenceScorer.ComputeTheoremConfidence(ComplexityAnalysis.Core.Recurrence.TheoremApplicability)">
            <summary>
            Computes confidence for a theorem applicability result.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.ConfidenceScorer.ComputeRefinementConfidence(ComplexityAnalysis.Solver.Refinement.RefinementResult)">
            <summary>
            Computes confidence for a refinement result.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.ConfidenceScorer.ComputeConsensusConfidence(System.Collections.Generic.IReadOnlyList{System.Double})">
            <summary>
            Computes combined confidence when multiple analyses agree.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.IConfidenceScorer">
            <summary>
            Interface for confidence scoring.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.ConfidenceAssessment">
            <summary>
            Complete confidence assessment for a complexity result.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.ConfidenceFactor">
            <summary>
            A single factor contributing to confidence.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.ConfidenceFactor.#ctor(System.String,System.Double,System.String)">
            <summary>
            A single factor contributing to confidence.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.ConfidenceLevel">
            <summary>
            Confidence level classification.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.AnalysisSource">
            <summary>
            Source of complexity analysis.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.VerificationStatus">
            <summary>
            Verification status of a result.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.AnalysisContext">
            <summary>
            Context for confidence analysis.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.NumericalFitData">
            <summary>
            Data from numerical fitting.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:ComplexityAnalysis.Solver.Refinement.InductionVerifier" -->
        <member name="M:ComplexityAnalysis.Solver.Refinement.InductionVerifier.#ctor(ComplexityAnalysis.Solver.SymPyRecurrenceSolver)">
            <summary>
            Creates an InductionVerifier. If sympySolver is provided, uses SymPy for exact verification.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.Refinement.InductionVerifier.Tolerance">
            <summary>Tolerance for numerical comparisons.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.Refinement.InductionVerifier.SamplePoints">
            <summary>Sample points for numerical verification.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.Refinement.InductionVerifier.LargeSamplePoints">
            <summary>Large sample points for asymptotic verification.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.Refinement.InductionVerifier.Instance">
            <summary>Default instance without SymPy support.</summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.InductionVerifier.WithSymPy(ComplexityAnalysis.Solver.SymPyRecurrenceSolver)">
            <summary>Creates an instance with SymPy support for exact verification.</summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.InductionVerifier.VerifyRecurrenceSolution(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Solver.Refinement.BoundType)">
            <summary>
            Verifies that a solution satisfies a recurrence relation.
            If SymPy solver is available, uses exact symbolic verification first.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.InductionVerifier.VerifyUpperBound(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Verifies an upper bound: T(n) = O(f(n)).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.InductionVerifier.VerifyLowerBound(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Verifies a lower bound: T(n) = Ω(f(n)).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.InductionVerifier.VerifySymbolically(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Performs symbolic induction verification when possible.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.InductionVerifier.TryVerifyWithSymPy(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Attempts verification using SymPy. Returns null if SymPy verification fails or is unavailable.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.InductionVerifier.TryConvertToLinearRecurrence(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation,System.Double[]@,System.Collections.Generic.Dictionary{System.Int32,System.Double}@,System.String@)">
            <summary>
            Converts a RecurrenceRelation to linear recurrence format for SymPy.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.IInductionVerifier">
            <summary>
            Interface for induction-based verification.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.BoundType">
            <summary>
            Type of asymptotic bound.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.InductionResult">
            <summary>
            Result of induction verification.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.BaseCaseVerification">
            <summary>
            Base case verification result.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.InductiveStepVerification">
            <summary>
            Inductive step verification result.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.AsymptoticVerification">
            <summary>
            Asymptotic behavior verification result.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.BoundVerificationResult">
            <summary>
            Bound verification result.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.SymbolicInductionResult">
            <summary>
            Result of symbolic induction verification.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.PerturbationExpansion">
             <summary>
             Handles near-boundary cases where standard theorems have gaps.
             Uses perturbation analysis and Taylor expansion to derive tighter bounds.
            
             Key cases:
             1. Master Theorem gap: f(n) = Θ(n^d) where d ≈ log_b(a)
             2. Akra-Bazzi boundary: p ≈ integer values
             3. Logarithmic factor boundaries: log^k(n) where k is non-integer
             </summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.Refinement.PerturbationExpansion.NearThreshold">
            <summary>Threshold for considering values "near" each other.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.Refinement.PerturbationExpansion.MaxTaylorOrder">
            <summary>Maximum order of Taylor expansion.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.Refinement.PerturbationExpansion.Tolerance">
            <summary>Tolerance for numerical comparisons.</summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.PerturbationExpansion.ExpandNearBoundary(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation,ComplexityAnalysis.Solver.Refinement.BoundaryCase)">
            <summary>
            Expands a recurrence solution near a boundary case.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.PerturbationExpansion.DetectBoundary(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation,ComplexityAnalysis.Core.Recurrence.TheoremApplicability)">
            <summary>
            Detects if a recurrence is near a boundary case.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.PerturbationExpansion.TaylorExpandIntegral(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,System.Double,System.Double)">
            <summary>
            Performs Taylor expansion of the Akra-Bazzi integral near a singular point.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.IPerturbationExpansion">
            <summary>
            Interface for perturbation expansion.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.PerturbationResult">
            <summary>
            Result of perturbation expansion.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.BoundaryCase">
            <summary>
            Description of a boundary case.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.BoundaryCaseType">
            <summary>
            Types of boundary cases.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.Refinement.BoundaryCaseType.MasterTheoremCase1To2">
            <summary>Near boundary between Master Theorem Case 1 and Case 2.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.Refinement.BoundaryCaseType.MasterTheoremCase2To3">
            <summary>Near boundary between Master Theorem Case 2 and Case 3.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.Refinement.BoundaryCaseType.AkraBazziIntegerExponent">
            <summary>Akra-Bazzi critical exponent near an integer.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.Refinement.BoundaryCaseType.LogarithmicBoundary">
            <summary>Logarithmic exponent boundary.</summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.TaylorExpansionResult">
            <summary>
            Result of Taylor expansion.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.TaylorTerm">
            <summary>
            A term in a Taylor expansion.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.TaylorTerm.#ctor(System.Int32,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            A term in a Taylor expansion.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.RefinementEngine">
             <summary>
             Main refinement engine that coordinates all refinement components.
             Implements Phase C of the complexity analysis pipeline.
            
             Pipeline:
             1. Receive initial solution from theorem solver (Phase B)
             2. Detect boundary cases and apply perturbation expansion
             3. Optimize slack variables for tighter bounds
             4. Verify via induction
             5. Compute confidence score
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.RefinementEngine.Refine(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation,ComplexityAnalysis.Core.Recurrence.TheoremApplicability,ComplexityAnalysis.Core.Progress.IAnalysisProgress)">
            <summary>
            Refines a complexity solution through the full pipeline.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.RefinementEngine.QuickRefine(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Performs quick refinement without full verification.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.RefinementEngine.VerifyBound(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Solver.Refinement.BoundType)">
            <summary>
            Verifies a proposed bound without refinement.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.IRefinementEngine">
            <summary>
            Interface for the refinement engine.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.RefinementPipelineResult">
            <summary>
            Complete result of the refinement pipeline.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.Refinement.RefinementPipelineResult.WasImproved">
            <summary>
            Returns true if the solution was improved during refinement.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.RefinementStage">
            <summary>
            A single stage in the refinement pipeline.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.QuickRefinementResult">
            <summary>
            Result of quick refinement.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.SlackVariableOptimizer">
             <summary>
             Optimizes complexity bounds by finding the tightest valid constants.
             Uses numerical verification to determine actual constant factors
             and asymptotic tightness.
            
             For example, if analysis yields O(n²), this optimizer can determine
             if the actual bound is Θ(n²) or if a tighter O(n log n) might apply.
             </summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.Refinement.SlackVariableOptimizer._samplePoints">
            <summary>Sample points for numerical verification.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.Refinement.SlackVariableOptimizer.Tolerance">
            <summary>Tolerance for ratio comparisons.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.Refinement.SlackVariableOptimizer.MaxIterations">
            <summary>Maximum iterations for optimization.</summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.SlackVariableOptimizer.Refine(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Refines a complexity bound by finding tighter constants.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.SlackVariableOptimizer.RefineRecurrence(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation,ComplexityAnalysis.Core.Recurrence.TheoremApplicability)">
            <summary>
            Refines a recurrence solution with verification.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.SlackVariableOptimizer.RefineGap(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation,System.Double,System.Double)">
            <summary>
            Finds tighter bounds for Master Theorem gap cases.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.ISlackVariableOptimizer">
            <summary>
            Interface for slack variable optimization.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.RefinementResult">
            <summary>
            Result of general refinement.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.RecurrenceRefinementResult">
            <summary>
            Result of recurrence refinement.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.GapRefinementResult">
            <summary>
            Result of gap refinement.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.VerificationResult">
            <summary>
            Verification result for numerical checking.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.GrowthAnalysis">
            <summary>
            Analysis of growth pattern.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.Refinement.GrowthAnalysis.#ctor(ComplexityAnalysis.Solver.Refinement.GrowthType,System.Double,System.Double)">
            <summary>
            Analysis of growth pattern.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.Refinement.GrowthType">
            <summary>
            Types of growth patterns.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.RegularityResult">
            <summary>
            Result of checking the regularity condition for Master Theorem Case 3.
            The regularity condition requires: a·f(n/b) ≤ c·f(n) for some c &lt; 1 and all sufficiently large n.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.RegularityResult.Holds">
            <summary>Whether the regularity condition holds.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.RegularityResult.BestC">
            <summary>
            The best (smallest) constant c found such that a·f(n/b) ≤ c·f(n).
            Null if regularity doesn't hold or couldn't be determined.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.RegularityResult.Reasoning">
            <summary>Human-readable explanation of the verification.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.RegularityResult.Confidence">
            <summary>Confidence level (0.0 to 1.0) in the result.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.RegularityResult.SamplePoints">
            <summary>The sample points used for numerical verification.</summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.RegularityResult.Success(System.Double,System.String,System.Double)">
            <summary>
            Creates a result indicating regularity holds.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.RegularityResult.Failure(System.String,System.Double)">
            <summary>
            Creates a result indicating regularity does not hold.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.RegularityResult.Indeterminate(System.String)">
            <summary>
            Creates a result indicating regularity could not be determined.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.IRegularityChecker">
             <summary>
             Verifies the regularity condition for Master Theorem Case 3.
            
             The regularity condition states: a·f(n/b) ≤ c·f(n) for some c &lt; 1
             and all sufficiently large n.
            
             This is equivalent to requiring that f(n) grows "regularly" without
             wild oscillations that could invalidate Case 3.
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.IRegularityChecker.CheckRegularity(System.Double,System.Double,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Checks if the regularity condition holds for the given parameters.
            </summary>
            <param name="a">Number of subproblems (a in T(n) = aT(n/b) + f(n)).</param>
            <param name="b">Division factor (b in T(n) = aT(n/b) + f(n)).</param>
            <param name="f">The non-recursive work function f(n).</param>
            <param name="variable">The variable (typically n).</param>
            <returns>Result indicating whether regularity holds.</returns>
        </member>
        <member name="T:ComplexityAnalysis.Solver.NumericalRegularityChecker">
             <summary>
             Numerical implementation of regularity checking using sampling.
            
             For common polynomial forms, regularity can be verified analytically:
             - f(n) = n^k: a·(n/b)^k ≤ c·n^k → a/b^k ≤ c, so c = a/b^k
               For Case 3, k > log_b(a), so b^k > a, thus a/b^k &lt; 1 ✓
            
             For more complex forms, we use numerical sampling.
             </summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.NumericalRegularityChecker.DefaultSamplePoints">
            <summary>Default sample points for numerical verification.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.NumericalRegularityChecker.Tolerance">
            <summary>Tolerance for numerical comparisons.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.NumericalRegularityChecker.MaxC">
            <summary>Maximum acceptable c value (must be strictly less than 1).</summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.NumericalRegularityChecker.TryAnalyticalVerification(System.Double,System.Double,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Attempts analytical verification for common f(n) forms.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.NumericalRegularityChecker.NumericalVerification(System.Double,System.Double,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,System.Double[])">
            <summary>
            Numerical verification by sampling f(n) at multiple points.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.SymPyRecurrenceSolver">
            <summary>
            Solves recurrence relations using SymPy via a Python subprocess.
            Uses 'uv run' for zero-config isolated execution.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.SymPyRecurrenceSolver.SolveLinearAsync(System.Double[],System.Collections.Generic.Dictionary{System.Int32,System.Double},System.String,System.Threading.CancellationToken)">
            <summary>
            Solves a linear recurrence: T(n) = sum(coeffs[i] * T(n-1-i)) + f(n)
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.SymPyRecurrenceSolver.SolveDivideAndConquerAsync(System.Double,System.Double,System.String,System.Threading.CancellationToken)">
            <summary>
            Solves a divide-and-conquer recurrence: T(n) = a*T(n/b) + f(n)
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.SymPyRecurrenceSolver.VerifyAsync(System.String,System.String,System.Collections.Generic.Dictionary{System.Int32,System.Double},System.Threading.CancellationToken)">
            <summary>
            Verifies that a proposed solution satisfies a recurrence.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.SymPyRecurrenceSolver.CompareAsync(System.String,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Compares asymptotic growth of two expressions using limits.
            Uses L'Hôpital's rule via SymPy for proper handling of indeterminate forms.
            </summary>
            <param name="f">First expression (e.g., "n**2")</param>
            <param name="g">Second expression (e.g., "n * log(n)")</param>
            <param name="boundType">Type of bound to verify: "O", "Omega", or "Theta"</param>
        </member>
        <member name="T:ComplexityAnalysis.Solver.AsymptoticComparisonResult">
            <summary>
            Result of asymptotic comparison between two expressions.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.AsymptoticComparisonResult.BoundType">
            <summary>Type of bound verified: "O", "Omega", or "Theta".</summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.AsymptoticComparisonResult.Holds">
            <summary>Whether the bound holds.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.AsymptoticComparisonResult.Constant">
            <summary>The constant c for O or Ω bounds.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.AsymptoticComparisonResult.Constants">
            <summary>The constants (c1, c2) for Θ bounds.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.AsymptoticComparisonResult.Comparison">
            <summary>
            Comparison result: "f &lt; g" (f = o(g)), "f ~ g" (f = Θ(g)), or "f &gt; g" (f = ω(g)).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Solver.AsymptoticComparisonResult.LimitRatio">
            <summary>The limit of f/g as n → ∞.</summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.RecurrenceSolution">
            <summary>
            Result of solving a recurrence relation.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.TheoremApplicabilityAnalyzer">
            <summary>
            Main analyzer that determines which recurrence-solving theorem applies
            and computes the closed-form solution.
            </summary>
            <remarks>
            <para>
            <b>Analysis Order:</b>
            </para>
            <list type="number">
              <item><description>
                <b>Master Theorem</b> - Tried first for single-term divide-and-conquer recurrences.
                Simpler conditions, more precise when applicable.
              </description></item>
              <item><description>
                <b>Akra-Bazzi Theorem</b> - Falls back for multi-term recurrences or when
                Master Theorem has gaps.
              </description></item>
              <item><description>
                <b>Linear Recurrence</b> - For T(n) = T(n-1) + f(n), solved by summation.
              </description></item>
              <item><description>
                <b>Failure with Diagnostics</b> - Reports why analysis failed with suggestions.
              </description></item>
            </list>
            
            <para>
            <b>Master Theorem:</b> For T(n) = a·T(n/b) + f(n) where a ≥ 1, b > 1:
            </para>
            <list type="table">
              <listheader>
                <term>Case</term>
                <description>Condition and Solution</description>
              </listheader>
              <item>
                <term>Case 1</term>
                <description>
                  f(n) = O(n^(log_b(a) - ε)) for some ε > 0 ⟹ T(n) = Θ(n^log_b(a))
                  <br/>Work dominated by leaves (recursion-heavy)
                </description>
              </item>
              <item>
                <term>Case 2</term>
                <description>
                  f(n) = Θ(n^log_b(a) · log^k n) for k ≥ 0 ⟹ T(n) = Θ(n^log_b(a) · log^(k+1) n)
                  <br/>Work balanced across all levels
                </description>
              </item>
              <item>
                <term>Case 3</term>
                <description>
                  f(n) = Ω(n^(log_b(a) + ε)) for some ε > 0, and regularity holds
                  ⟹ T(n) = Θ(f(n))
                  <br/>Work dominated by root (merge-heavy)
                </description>
              </item>
            </list>
            
            <para>
            <b>Master Theorem Gaps:</b> The theorem has gaps when f(n) falls between cases
            without satisfying the polynomial separation requirement (ε > 0). For example,
            f(n) = n^log_b(a) / log(n) is asymptotically smaller than Θ(n^log_b(a)) but not
            polynomially smaller.
            </para>
            
            <para>
            <b>Akra-Bazzi Theorem:</b> For T(n) = Σᵢ aᵢ·T(bᵢn) + g(n) where aᵢ > 0 and 0 &lt; bᵢ &lt; 1:
            </para>
            <code>
            T(n) = Θ(n^p · (1 + ∫₁ⁿ g(u)/u^(p+1) du))
            </code>
            <para>
            where p is the unique solution to Σᵢ aᵢ·bᵢ^p = 1.
            </para>
            <para>
            Akra-Bazzi handles more cases than Master Theorem:
            </para>
            <list type="bullet">
              <item><description>Multiple recursive terms (e.g., T(n) = T(n/3) + T(2n/3) + O(n))</description></item>
              <item><description>Non-equal subproblem sizes</description></item>
              <item><description>No polynomial gap requirement (covers Master Theorem gaps)</description></item>
            </list>
            </remarks>
            <seealso cref="T:ComplexityAnalysis.Core.Recurrence.MasterTheoremApplicable"/>
            <seealso cref="T:ComplexityAnalysis.Core.Recurrence.AkraBazziApplicable"/>
            <seealso cref="T:ComplexityAnalysis.Core.Recurrence.TheoremApplicability"/>
        </member>
        <member name="F:ComplexityAnalysis.Solver.TheoremApplicabilityAnalyzer.Epsilon">
            <summary>Tolerance for numerical comparisons.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Solver.TheoremApplicabilityAnalyzer.MinEpsilon">
            <summary>Minimum epsilon for Master Theorem cases 1 and 3.</summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.TheoremApplicabilityAnalyzer.Analyze(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation)">
            <summary>
            Analyzes a recurrence and determines which theorem applies.
            Tries Master Theorem first, then Akra-Bazzi, then linear recurrence.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.TheoremApplicabilityAnalyzer.AnalyzeWithAkraBazzi(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation)">
            <summary>
            Forces Akra-Bazzi analysis even for single-term recurrences.
            Useful for cross-validation testing.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.TheoremApplicabilityAnalyzer.ValidateRecurrence(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation)">
            <summary>
            Validates that the recurrence is well-formed.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.TheoremApplicabilityAnalyzer.CheckMasterTheorem(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation)">
            <summary>
            Checks Master Theorem applicability for T(n) = a·T(n/b) + f(n).
            </summary>
            <remarks>
            <para>
            The Master Theorem requires:
            </para>
            <list type="bullet">
              <item><description>Exactly one recursive term</description></item>
              <item><description>a ≥ 1 (at least one recursive call)</description></item>
              <item><description>b > 1 (subproblem must be smaller)</description></item>
            </list>
            
            <para>
            <b>Case Determination:</b> Computes log_b(a) and classifies f(n) to determine
            which case applies. The <see cref="F:ComplexityAnalysis.Solver.TheoremApplicabilityAnalyzer.MinEpsilon"/> threshold (0.01) determines
            when f(n) is "polynomially" different from n^log_b(a).
            </para>
            
            <para>
            <b>Case 3 Regularity:</b> Requires that a·f(n/b) ≤ c·f(n) for some c &lt; 1.
            This is verified by <see cref="T:ComplexityAnalysis.Solver.IRegularityChecker"/>.
            </para>
            </remarks>
        </member>
        <member name="M:ComplexityAnalysis.Solver.TheoremApplicabilityAnalyzer.CheckAkraBazzi(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation)">
            <summary>
            Checks Akra-Bazzi theorem applicability for multi-term recurrences.
            </summary>
            <remarks>
            <para>
            The Akra-Bazzi theorem applies to recurrences of the form:
            T(n) = Σᵢ aᵢ·T(bᵢn + hᵢ(n)) + g(n)
            </para>
            <para>
            <b>Requirements:</b>
            </para>
            <list type="bullet">
              <item><description>All aᵢ > 0 (positive coefficients)</description></item>
              <item><description>All bᵢ ∈ (0, 1) (proper size reduction)</description></item>
              <item><description>g(n) satisfies polynomial growth condition</description></item>
            </list>
            
            <para>
            <b>Solution Process:</b>
            </para>
            <list type="number">
              <item><description>
                Solve Σᵢ aᵢ·bᵢ^p = 1 for critical exponent p using Newton's method
              </description></item>
              <item><description>
                Evaluate ∫₁ⁿ g(u)/u^(p+1) du (the "driving function" integral)
              </description></item>
              <item><description>
                Combine: T(n) = Θ(n^p · (1 + integral result))
              </description></item>
            </list>
            
            <para>
            <b>Advantages over Master Theorem:</b>
            </para>
            <list type="bullet">
              <item><description>Handles multiple recursive terms</description></item>
              <item><description>No gaps between cases</description></item>
              <item><description>More general driving functions g(n)</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:ComplexityAnalysis.Solver.TheoremApplicabilityAnalyzer.CheckLinearRecurrence(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation)">
            <summary>
            Checks for linear recurrence T(n) = T(n-1) + f(n).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Solver.RecurrenceAnalysisExtensions">
            <summary>
            Extension methods for convenient analysis.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.RecurrenceAnalysisExtensions.Analyze(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation)">
            <summary>
            Analyzes a recurrence relation using the default analyzer.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.RecurrenceAnalysisExtensions.Analyze(ComplexityAnalysis.Core.Recurrence.RecurrenceComplexity)">
            <summary>
            Analyzes a RecurrenceComplexity using the default analyzer.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.RecurrenceAnalysisExtensions.BinaryDivideAndConquer(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates a binary divide-and-conquer recurrence T(n) = 2T(n/2) + f(n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.RecurrenceAnalysisExtensions.KaratsubaStyle(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates a Karatsuba-style recurrence T(n) = 3T(n/2) + f(n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Solver.RecurrenceAnalysisExtensions.StrassenStyle(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates a Strassen-style recurrence T(n) = 7T(n/2) + f(n).
            </summary>
        </member>
    </members>
</doc>
