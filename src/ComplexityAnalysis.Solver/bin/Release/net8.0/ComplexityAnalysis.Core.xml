<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ComplexityAnalysis.Core</name>
    </assembly>
    <members>
        <member name="T:ComplexityAnalysis.Core.Complexity.AmortizedComplexity">
            <summary>
            Represents amortized complexity - the average cost per operation over a sequence.
            
            Amortized analysis accounts for expensive operations that happen infrequently,
            giving a more accurate picture of average-case performance.
            
            Examples:
            - Dynamic array Add: O(n) worst case, O(1) amortized
            - Hash table insert: O(n) worst case, O(1) amortized
            - Splay tree operations: O(n) worst case, O(log n) amortized
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.AmortizedComplexity.AmortizedCost">
            <summary>
            The amortized (average) complexity per operation.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.AmortizedComplexity.WorstCaseCost">
            <summary>
            The worst-case complexity for a single operation.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.AmortizedComplexity.Method">
            <summary>
            The method used to derive the amortized bound.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.AmortizedComplexity.Potential">
            <summary>
            Optional potential function used for analysis.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.AmortizedComplexity.Description">
            <summary>
            Description of the amortization scenario.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.AmortizedComplexity.ConstantAmortized(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates an amortized constant complexity (like List.Add).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.AmortizedComplexity.LogarithmicAmortized(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates an amortized logarithmic complexity (like splay tree operations).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.AmortizedComplexity.InverseAckermannAmortized(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates an inverse Ackermann amortized complexity (like Union-Find).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.AmortizationMethod">
            <summary>
            Methods for deriving amortized bounds.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.AmortizationMethod.Aggregate">
            <summary>
            Aggregate method: Total cost / number of operations.
            Simple but doesn't give per-operation insight.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.AmortizationMethod.Accounting">
            <summary>
            Accounting method: Assign credits to operations.
            Cheap operations pay for expensive ones.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.AmortizationMethod.Potential">
            <summary>
            Potential method: Define potential function Φ(state).
            Amortized cost = actual cost + ΔΦ.
            Most powerful, gives tight bounds.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.PotentialFunction">
            <summary>
            Represents a potential function for amortized analysis.
            Φ: DataStructureState → ℝ≥0
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.PotentialFunction.Name">
            <summary>
            Name/description of the potential function.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.PotentialFunction.Formula">
            <summary>
            Mathematical description of the potential function.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.PotentialFunction.SizeVariable">
            <summary>
            The variable representing the data structure size.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.PotentialFunction.Common">
            <summary>
            Common potential functions.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.PotentialFunction.Common.DynamicArray">
            <summary>
            Dynamic array: Φ = 2n - capacity
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.PotentialFunction.Common.HashTable">
            <summary>
            Hash table: Φ = 2n - buckets
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.PotentialFunction.Common.BinaryCounter">
            <summary>
            Binary counter: Φ = number of 1-bits
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.PotentialFunction.Common.MultipopStack">
            <summary>
            Stack with multipop: Φ = stack size
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.PotentialFunction.Common.SplayTree">
            <summary>
            Splay tree: Φ = Σ log(size of subtree)
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.PotentialFunction.Common.UnionFind">
            <summary>
            Union-Find: Φ based on ranks
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.InverseAckermannComplexity">
            <summary>
            Inverse Ackermann complexity: O(α(n)) - effectively constant for practical inputs.
            Used in Union-Find with path compression and union by rank.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.InverseAckermannComplexity.#ctor(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Inverse Ackermann complexity: O(α(n)) - effectively constant for practical inputs.
            Used in Union-Find with path compression and union by rank.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.InverseAckermannComplexity.InverseAckermann(System.Int64)">
            <summary>
            Computes inverse Ackermann function α(n).
            α(n) = min { k : A(k, k) ≥ n } where A is Ackermann function.
            For all practical n, α(n) ≤ 4.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.IAmortizedComplexityVisitor`1">
            <summary>
            Extended visitor interface for amortized complexity types.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ComplexityComposition">
            <summary>
            Provides methods for composing complexity expressions based on control flow patterns.
            These rules form the foundation of static complexity analysis.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.Sequential(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
             <summary>
             Sequential composition: T₁ followed by T₂.
             Total complexity: O(T₁ + T₂)
            
             In Big-O terms, the dominant term will dominate:
             O(n) + O(n²) = O(n²)
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.Sequential(ComplexityAnalysis.Core.Complexity.ComplexityExpression[])">
            <summary>
            Sequential composition of multiple expressions.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.Sequential(System.Collections.Generic.IEnumerable{ComplexityAnalysis.Core.Complexity.ComplexityExpression})">
            <summary>
            Sequential composition of multiple expressions.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.Nested(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
             <summary>
             Nested composition: T₁ inside T₂ (e.g., nested loops).
             Total complexity: O(T₁ × T₂)
            
             Example: for i in 0..n: for j in 0..n: O(1)
             Result: O(n) × O(n) × O(1) = O(n²)
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.Nested(ComplexityAnalysis.Core.Complexity.ComplexityExpression[])">
            <summary>
            Nested composition of multiple expressions (deeply nested loops).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.Nested(System.Collections.Generic.IEnumerable{ComplexityAnalysis.Core.Complexity.ComplexityExpression})">
            <summary>
            Nested composition of multiple expressions.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.Branching(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
             <summary>
             Branching composition: if-else statement.
             Total complexity: O(max(T_true, T_false))
            
             We take the worst case because either branch might execute.
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.BranchingWithCondition(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Branching composition with condition overhead.
            Total complexity: O(T_condition + max(T_true, T_false))
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.Switch(System.Collections.Generic.IEnumerable{ComplexityAnalysis.Core.Complexity.ComplexityExpression})">
            <summary>
            Multi-way branching (switch/match).
            Total complexity: O(max(T₁, T₂, ..., Tₙ))
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.Loop(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Loop composition with known iteration count.
            Total complexity: O(iterations × body)
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.ForLoop(ComplexityAnalysis.Core.Complexity.Variable,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            For loop with linear iterations: for i = 0 to n.
            Total complexity: O(n × body)
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.BoundedForLoop(System.Int32,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            For loop with bounded iterations: for i = 0 to constant.
            Total complexity: O(body) (the constant factor is absorbed)
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.LogarithmicLoop(ComplexityAnalysis.Core.Complexity.Variable,ComplexityAnalysis.Core.Complexity.ComplexityExpression,System.Double)">
            <summary>
            Logarithmic loop: for i = 1; i &lt; n; i *= 2.
            Total complexity: O(log n × body)
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.LoopWithEarlyExit(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression,System.Boolean)">
             <summary>
             Early exit pattern: loop that may terminate early.
             Total complexity: O(min(early_exit, full_iterations) × body)
            
             For worst-case analysis, we typically use the full iterations.
             For average-case, the expected early exit point matters.
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.LinearRecursion(ComplexityAnalysis.Core.Complexity.Variable,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
             <summary>
             Recursive composition: function calls itself.
             Returns a RecurrenceComplexity that needs to be solved.
            
             For T(n) = T(n-1) + work, this creates:
             RecurrenceComplexity with linear reduction.
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.DivideAndConquer(ComplexityAnalysis.Core.Complexity.Variable,System.Int32,System.Int32,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Divide and conquer recursion: T(n) = a × T(n/b) + work.
            Returns a RecurrenceComplexity that can be solved via Master Theorem.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.BinaryRecursion(ComplexityAnalysis.Core.Complexity.Variable,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Binary recursion: T(n) = 2T(n/2) + work.
            Common pattern for divide and conquer algorithms.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.FunctionCall(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Function call composition: calling a function with known complexity.
            Total complexity: O(argument_setup + function_complexity)
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.Amortized(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
             <summary>
             Amortized operation: multiple operations with varying individual costs
             but known total cost over n operations.
            
             Example: n insertions into a dynamic array = O(n) total, O(1) amortized per op.
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityComposition.Conditional(System.String,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Conditional complexity: different complexity based on runtime condition.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ComplexityBuilder">
            <summary>
            Fluent builder for constructing complex complexity expressions.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityBuilder.Constant">
            <summary>
            Start building with O(1).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityBuilder.Linear(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Start building with O(n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityBuilder.Then(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Add sequential operation: current + next.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityBuilder.InsideLoop(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Nest inside a loop: iterations × current.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityBuilder.InsideLinearLoop(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Nest inside a loop over n.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityBuilder.OrBranch(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Add branch: max(current, alternative).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityBuilder.Times(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Multiply by a factor.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityBuilder.Build">
            <summary>
            Build the final expression.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityBuilder.op_Implicit(ComplexityAnalysis.Core.Complexity.ComplexityBuilder)~ComplexityAnalysis.Core.Complexity.ComplexityExpression">
            <summary>
            Implicit conversion to ComplexityExpression.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ComplexityExpression">
            <summary>
            Base type for all complexity expressions representing algorithmic time or space complexity.
            </summary>
            <remarks>
            <para>
            <b>Design Philosophy:</b> This forms the core of an expression-based complexity algebra
            that represents Big-O expressions as composable Abstract Syntax Trees (AST). This design
            enables:
            </para>
            <list type="bullet">
              <item><description>Type-safe composition of complexity expressions</description></item>
              <item><description>Algebraic simplification (e.g., O(n) + O(n²) → O(n²))</description></item>
              <item><description>Variable substitution for parametric complexity</description></item>
              <item><description>Evaluation for specific input sizes</description></item>
              <item><description>Visitor pattern for transformation and analysis</description></item>
            </list>
            
            <para>
            <b>Type Hierarchy:</b>
            </para>
            <list type="table">
              <listheader>
                <term>Category</term>
                <description>Types</description>
              </listheader>
              <item>
                <term>Primitive</term>
                <description>
                  <see cref="T:ComplexityAnalysis.Core.Complexity.ConstantComplexity"/> (O(1)),
                  <see cref="T:ComplexityAnalysis.Core.Complexity.VariableComplexity"/> (O(n)),
                  <see cref="T:ComplexityAnalysis.Core.Complexity.LinearComplexity"/> (O(k·n))
                </description>
              </item>
              <item>
                <term>Polynomial</term>
                <description>
                  <see cref="T:ComplexityAnalysis.Core.Complexity.PolynomialComplexity"/> (O(n²), O(n³), etc.),
                  <see cref="T:ComplexityAnalysis.Core.Complexity.PolyLogComplexity"/> (O(n log n))
                </description>
              </item>
              <item>
                <term>Transcendental</term>
                <description>
                  <see cref="T:ComplexityAnalysis.Core.Complexity.LogarithmicComplexity"/> (O(log n)),
                  <see cref="T:ComplexityAnalysis.Core.Complexity.ExponentialComplexity"/> (O(2ⁿ)),
                  <see cref="T:ComplexityAnalysis.Core.Complexity.FactorialComplexity"/> (O(n!))
                </description>
              </item>
              <item>
                <term>Compositional</term>
                <description>
                  <see cref="T:ComplexityAnalysis.Core.Complexity.BinaryOperationComplexity"/> (+, ×, max, min),
                  <see cref="T:ComplexityAnalysis.Core.Complexity.ConditionalComplexity"/> (branching)
                </description>
              </item>
            </list>
            
            <para>
            <b>Composition Rules:</b>
            </para>
            <code>
            // Sequential (addition): loops following loops
            var seq = new BinaryOperationComplexity(O_n, BinaryOp.Plus, O_logN);
            // → O(n + log n) → O(n) after simplification
            
            // Nested (multiplication): loops inside loops
            var nested = new BinaryOperationComplexity(O_n, BinaryOp.Multiply, O_m);
            // → O(n × m)
            
            // Branching (max): if-else with different complexities
            var branch = new BinaryOperationComplexity(O_n, BinaryOp.Max, O_nSquared);
            // → O(max(n, n²)) → O(n²)
            </code>
            
            <para>
            All expressions are implemented as immutable records for thread-safety and
            functional composition patterns.
            </para>
            </remarks>
            <seealso cref="T:ComplexityAnalysis.Core.Complexity.IComplexityVisitor`1"/>
            <seealso cref="T:ComplexityAnalysis.Core.Complexity.ComplexityComposition"/>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityExpression.Accept``1(ComplexityAnalysis.Core.Complexity.IComplexityVisitor{``0})">
            <summary>
            Accept a visitor for the expression tree.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityExpression.Substitute(ComplexityAnalysis.Core.Complexity.Variable,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Substitute a variable with another expression.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ComplexityExpression.FreeVariables">
            <summary>
            Get all free (unbound) variables in this expression.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityExpression.Evaluate(System.Collections.Generic.IReadOnlyDictionary{ComplexityAnalysis.Core.Complexity.Variable,System.Double})">
            <summary>
            Evaluate the expression for a given variable assignment.
            Returns null if evaluation is not possible (e.g., missing variables).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityExpression.ToBigONotation">
            <summary>
            Get a human-readable string representation in Big-O notation.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ConstantComplexity">
            <summary>
            Represents a constant complexity: O(1) or O(k) for some constant k.
            </summary>
            <remarks>
            <para>
            Constant complexity represents operations whose execution time does not depend
            on input size. Common sources include:
            </para>
            <list type="bullet">
              <item><description>Array indexing: <c>arr[i]</c></description></item>
              <item><description>Hash table lookup (amortized): <c>dict[key]</c></description></item>
              <item><description>Arithmetic operations: <c>a + b * c</c></description></item>
              <item><description>Base cases of recursive algorithms</description></item>
            </list>
            <para>
            The <see cref="P:ComplexityAnalysis.Core.Complexity.ConstantComplexity.Value"/> property captures any constant factor, though in
            asymptotic analysis O(1) = O(k) for any constant k.
            </para>
            </remarks>
            <param name="Value">The constant value (typically 1).</param>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ConstantComplexity.#ctor(System.Double)">
            <summary>
            Represents a constant complexity: O(1) or O(k) for some constant k.
            </summary>
            <remarks>
            <para>
            Constant complexity represents operations whose execution time does not depend
            on input size. Common sources include:
            </para>
            <list type="bullet">
              <item><description>Array indexing: <c>arr[i]</c></description></item>
              <item><description>Hash table lookup (amortized): <c>dict[key]</c></description></item>
              <item><description>Arithmetic operations: <c>a + b * c</c></description></item>
              <item><description>Base cases of recursive algorithms</description></item>
            </list>
            <para>
            The <see cref="P:ComplexityAnalysis.Core.Complexity.ConstantComplexity.Value"/> property captures any constant factor, though in
            asymptotic analysis O(1) = O(k) for any constant k.
            </para>
            </remarks>
            <param name="Value">The constant value (typically 1).</param>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ConstantComplexity.Value">
            <summary>The constant value (typically 1).</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ConstantComplexity.One">
            <summary>
            The canonical O(1) constant complexity.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ConstantComplexity.Zero">
            <summary>
            Zero complexity (for base cases).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.VariableComplexity">
            <summary>
            Represents a single variable complexity: O(n), O(V), O(E), etc.
            </summary>
            <remarks>
            <para>
            This is the simplest form of linear complexity—a single variable without
            a coefficient. For complexity with coefficients, see <see cref="T:ComplexityAnalysis.Core.Complexity.LinearComplexity"/>.
            </para>
            <para>
            Common variable types defined in <see cref="T:ComplexityAnalysis.Core.Complexity.Variable"/>:
            </para>
            <list type="bullet">
              <item><description><c>n</c> - General input size</description></item>
              <item><description><c>V</c> - Vertex count in graphs</description></item>
              <item><description><c>E</c> - Edge count in graphs</description></item>
              <item><description><c>m</c> - Secondary size parameter (e.g., pattern length)</description></item>
            </list>
            </remarks>
            <param name="Var">The variable representing the input size.</param>
            <seealso cref="T:ComplexityAnalysis.Core.Complexity.Variable"/>
            <seealso cref="T:ComplexityAnalysis.Core.Complexity.VariableType"/>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.VariableComplexity.#ctor(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Represents a single variable complexity: O(n), O(V), O(E), etc.
            </summary>
            <remarks>
            <para>
            This is the simplest form of linear complexity—a single variable without
            a coefficient. For complexity with coefficients, see <see cref="T:ComplexityAnalysis.Core.Complexity.LinearComplexity"/>.
            </para>
            <para>
            Common variable types defined in <see cref="T:ComplexityAnalysis.Core.Complexity.Variable"/>:
            </para>
            <list type="bullet">
              <item><description><c>n</c> - General input size</description></item>
              <item><description><c>V</c> - Vertex count in graphs</description></item>
              <item><description><c>E</c> - Edge count in graphs</description></item>
              <item><description><c>m</c> - Secondary size parameter (e.g., pattern length)</description></item>
            </list>
            </remarks>
            <param name="Var">The variable representing the input size.</param>
            <seealso cref="T:ComplexityAnalysis.Core.Complexity.Variable"/>
            <seealso cref="T:ComplexityAnalysis.Core.Complexity.VariableType"/>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.VariableComplexity.Var">
            <summary>The variable representing the input size.</summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.LinearComplexity">
            <summary>
            Represents linear complexity with a coefficient: O(k·n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.LinearComplexity.#ctor(System.Double,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Represents linear complexity with a coefficient: O(k·n).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.PolynomialComplexity">
            <summary>
            Represents polynomial complexity: O(n²), O(n³), or general polynomial forms.
            </summary>
            <remarks>
            <para>
            Polynomials represent algorithms with nested loops or recursive patterns that
            process proportional fractions of input at each level.
            </para>
            <para>
            <b>Structure:</b> The <see cref="P:ComplexityAnalysis.Core.Complexity.PolynomialComplexity.Coefficients"/> dictionary maps degree → coefficient.
            For example:
            </para>
            <list type="bullet">
              <item><description><c>{2: 1}</c> represents n²</description></item>
              <item><description><c>{2: 3, 1: 2}</c> represents 3n² + 2n</description></item>
              <item><description><c>{3: 1, 2: 1, 1: 1}</c> represents n³ + n² + n</description></item>
            </list>
            <para>
            <b>Common algorithmic sources:</b>
            </para>
            <list type="bullet">
              <item><description>O(n²): Bubble sort, insertion sort, naive matrix operations</description></item>
              <item><description>O(n³): Standard matrix multiplication, Floyd-Warshall</description></item>
              <item><description>O(n⁴): Naive bipartite matching</description></item>
            </list>
            <para>
            <b>Note:</b> For non-integer exponents (e.g., O(n^2.807) for Strassen), use
            <see cref="T:ComplexityAnalysis.Core.Complexity.PowerComplexity"/> or <see cref="T:ComplexityAnalysis.Core.Complexity.PolyLogComplexity"/> instead.
            </para>
            </remarks>
            <param name="Coefficients">Dictionary mapping degree → coefficient.</param>
            <param name="Var">The variable over which the polynomial is defined.</param>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.PolynomialComplexity.#ctor(System.Collections.Immutable.ImmutableDictionary{System.Int32,System.Double},ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Represents polynomial complexity: O(n²), O(n³), or general polynomial forms.
            </summary>
            <remarks>
            <para>
            Polynomials represent algorithms with nested loops or recursive patterns that
            process proportional fractions of input at each level.
            </para>
            <para>
            <b>Structure:</b> The <see cref="P:ComplexityAnalysis.Core.Complexity.PolynomialComplexity.Coefficients"/> dictionary maps degree → coefficient.
            For example:
            </para>
            <list type="bullet">
              <item><description><c>{2: 1}</c> represents n²</description></item>
              <item><description><c>{2: 3, 1: 2}</c> represents 3n² + 2n</description></item>
              <item><description><c>{3: 1, 2: 1, 1: 1}</c> represents n³ + n² + n</description></item>
            </list>
            <para>
            <b>Common algorithmic sources:</b>
            </para>
            <list type="bullet">
              <item><description>O(n²): Bubble sort, insertion sort, naive matrix operations</description></item>
              <item><description>O(n³): Standard matrix multiplication, Floyd-Warshall</description></item>
              <item><description>O(n⁴): Naive bipartite matching</description></item>
            </list>
            <para>
            <b>Note:</b> For non-integer exponents (e.g., O(n^2.807) for Strassen), use
            <see cref="T:ComplexityAnalysis.Core.Complexity.PowerComplexity"/> or <see cref="T:ComplexityAnalysis.Core.Complexity.PolyLogComplexity"/> instead.
            </para>
            </remarks>
            <param name="Coefficients">Dictionary mapping degree → coefficient.</param>
            <param name="Var">The variable over which the polynomial is defined.</param>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.PolynomialComplexity.Coefficients">
            <summary>Dictionary mapping degree → coefficient.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.PolynomialComplexity.Var">
            <summary>The variable over which the polynomial is defined.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.PolynomialComplexity.Degree">
            <summary>
            The highest degree in the polynomial (dominant term).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.PolynomialComplexity.LeadingCoefficient">
            <summary>
            The coefficient of the highest degree term.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.PolynomialComplexity.OfDegree(System.Int32,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates a simple polynomial of the form O(n^k).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.PolynomialComplexity.OfDegree(System.Double,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates a polynomial approximation for non-integer degrees.
            Note: This rounds to the nearest integer since PolynomialComplexity
            only supports integer exponents. For exact non-integer exponents,
            use PowerComplexity instead.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.LogarithmicComplexity">
            <summary>
            Represents logarithmic complexity: O(log n), O(k·log n), with configurable base.
            </summary>
            <remarks>
            <para>
            Logarithmic complexity typically arises from algorithms that halve (or divide by
            a constant) the problem size at each step.
            </para>
            <para>
            <b>Common algorithmic sources:</b>
            </para>
            <list type="bullet">
              <item><description>Binary search: O(log n)</description></item>
              <item><description>Balanced BST operations: O(log n)</description></item>
              <item><description>Exponentiation by squaring: O(log n)</description></item>
            </list>
            <para>
            <b>Base equivalence:</b> In asymptotic analysis, log₂(n) = Θ(logₖ(n)) for any
            constant k > 1, since logₖ(n) = log₂(n) / log₂(k). The base is preserved
            for precision in constant factor analysis.
            </para>
            </remarks>
            <param name="Coefficient">Multiplicative coefficient (default 1).</param>
            <param name="Var">The variable inside the logarithm.</param>
            <param name="Base">Logarithm base (default 2 for binary algorithms).</param>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.LogarithmicComplexity.#ctor(System.Double,ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
            <summary>
            Represents logarithmic complexity: O(log n), O(k·log n), with configurable base.
            </summary>
            <remarks>
            <para>
            Logarithmic complexity typically arises from algorithms that halve (or divide by
            a constant) the problem size at each step.
            </para>
            <para>
            <b>Common algorithmic sources:</b>
            </para>
            <list type="bullet">
              <item><description>Binary search: O(log n)</description></item>
              <item><description>Balanced BST operations: O(log n)</description></item>
              <item><description>Exponentiation by squaring: O(log n)</description></item>
            </list>
            <para>
            <b>Base equivalence:</b> In asymptotic analysis, log₂(n) = Θ(logₖ(n)) for any
            constant k > 1, since logₖ(n) = log₂(n) / log₂(k). The base is preserved
            for precision in constant factor analysis.
            </para>
            </remarks>
            <param name="Coefficient">Multiplicative coefficient (default 1).</param>
            <param name="Var">The variable inside the logarithm.</param>
            <param name="Base">Logarithm base (default 2 for binary algorithms).</param>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.LogarithmicComplexity.Coefficient">
            <summary>Multiplicative coefficient (default 1).</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.LogarithmicComplexity.Var">
            <summary>The variable inside the logarithm.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.LogarithmicComplexity.Base">
            <summary>Logarithm base (default 2 for binary algorithms).</summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ExponentialComplexity">
            <summary>
            Represents exponential complexity: O(k^n), O(2^n), etc.
            </summary>
            <remarks>
            <para>
            Exponential complexity indicates algorithms with explosive growth, typically
            arising from exhaustive enumeration or branching recursive patterns without
            memoization.
            </para>
            <para>
            <b>Common algorithmic sources:</b>
            </para>
            <list type="bullet">
              <item><description>Brute-force subset enumeration: O(2ⁿ)</description></item>
              <item><description>Naive recursive Fibonacci: O(φⁿ) ≈ O(1.618ⁿ)</description></item>
              <item><description>Traveling salesman (brute force): O(n! × n) ≈ O(nⁿ)</description></item>
              <item><description>3-SAT exhaustive search: O(3ⁿ)</description></item>
            </list>
            <para>
            <b>Growth comparison:</b> 2¹⁰ = 1,024 but 2²⁰ ≈ 1 million and 2³⁰ ≈ 1 billion.
            Exponential algorithms become infeasible very quickly.
            </para>
            </remarks>
            <param name="Base">The exponential base (e.g., 2 for O(2ⁿ)).</param>
            <param name="Var">The variable in the exponent.</param>
            <param name="Coefficient">Optional multiplicative coefficient.</param>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ExponentialComplexity.#ctor(System.Double,ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
            <summary>
            Represents exponential complexity: O(k^n), O(2^n), etc.
            </summary>
            <remarks>
            <para>
            Exponential complexity indicates algorithms with explosive growth, typically
            arising from exhaustive enumeration or branching recursive patterns without
            memoization.
            </para>
            <para>
            <b>Common algorithmic sources:</b>
            </para>
            <list type="bullet">
              <item><description>Brute-force subset enumeration: O(2ⁿ)</description></item>
              <item><description>Naive recursive Fibonacci: O(φⁿ) ≈ O(1.618ⁿ)</description></item>
              <item><description>Traveling salesman (brute force): O(n! × n) ≈ O(nⁿ)</description></item>
              <item><description>3-SAT exhaustive search: O(3ⁿ)</description></item>
            </list>
            <para>
            <b>Growth comparison:</b> 2¹⁰ = 1,024 but 2²⁰ ≈ 1 million and 2³⁰ ≈ 1 billion.
            Exponential algorithms become infeasible very quickly.
            </para>
            </remarks>
            <param name="Base">The exponential base (e.g., 2 for O(2ⁿ)).</param>
            <param name="Var">The variable in the exponent.</param>
            <param name="Coefficient">Optional multiplicative coefficient.</param>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ExponentialComplexity.Base">
            <summary>The exponential base (e.g., 2 for O(2ⁿ)).</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ExponentialComplexity.Var">
            <summary>The variable in the exponent.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ExponentialComplexity.Coefficient">
            <summary>Optional multiplicative coefficient.</summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.FactorialComplexity">
            <summary>
            Represents factorial complexity: O(n!).
            </summary>
            <remarks>
            <para>
            Factorial complexity represents the most extreme form of combinatorial explosion,
            growing faster than exponential. By Stirling's approximation:
            n! ≈ √(2πn) × (n/e)ⁿ
            </para>
            <para>
            <b>Common algorithmic sources:</b>
            </para>
            <list type="bullet">
              <item><description>Generating all permutations: O(n!)</description></item>
              <item><description>Traveling salesman brute force: O(n!)</description></item>
              <item><description>Determinant by definition: O(n!)</description></item>
            </list>
            <para>
            <b>Growth illustration:</b> 10! = 3,628,800 while 20! ≈ 2.4 × 10¹⁸.
            Factorial algorithms are typically only feasible for n ≤ 12.
            </para>
            </remarks>
            <param name="Var">The variable in the factorial.</param>
            <param name="Coefficient">Optional multiplicative coefficient.</param>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.FactorialComplexity.#ctor(ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
            <summary>
            Represents factorial complexity: O(n!).
            </summary>
            <remarks>
            <para>
            Factorial complexity represents the most extreme form of combinatorial explosion,
            growing faster than exponential. By Stirling's approximation:
            n! ≈ √(2πn) × (n/e)ⁿ
            </para>
            <para>
            <b>Common algorithmic sources:</b>
            </para>
            <list type="bullet">
              <item><description>Generating all permutations: O(n!)</description></item>
              <item><description>Traveling salesman brute force: O(n!)</description></item>
              <item><description>Determinant by definition: O(n!)</description></item>
            </list>
            <para>
            <b>Growth illustration:</b> 10! = 3,628,800 while 20! ≈ 2.4 × 10¹⁸.
            Factorial algorithms are typically only feasible for n ≤ 12.
            </para>
            </remarks>
            <param name="Var">The variable in the factorial.</param>
            <param name="Coefficient">Optional multiplicative coefficient.</param>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.FactorialComplexity.Var">
            <summary>The variable in the factorial.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.FactorialComplexity.Coefficient">
            <summary>Optional multiplicative coefficient.</summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.BinaryOperationComplexity">
            <summary>
            Binary operation on complexity expressions for compositional analysis.
            </summary>
            <remarks>
            <para>
            Binary operations form the backbone of complexity composition, mapping code
            structure to complexity algebra:
            </para>
            <list type="table">
              <listheader>
                <term>Operation</term>
                <description>Code Pattern</description>
              </listheader>
              <item>
                <term><see cref="F:ComplexityAnalysis.Core.Complexity.BinaryOp.Plus"/> (T₁ + T₂)</term>
                <description>Sequential code blocks: <c>loop1(); loop2();</c></description>
              </item>
              <item>
                <term><see cref="F:ComplexityAnalysis.Core.Complexity.BinaryOp.Multiply"/> (T₁ × T₂)</term>
                <description>Nested loops: <c>for(...) { for(...) { } }</c></description>
              </item>
              <item>
                <term><see cref="F:ComplexityAnalysis.Core.Complexity.BinaryOp.Max"/> (max(T₁, T₂))</term>
                <description>Branching: <c>if(cond) { slow } else { fast }</c></description>
              </item>
              <item>
                <term><see cref="F:ComplexityAnalysis.Core.Complexity.BinaryOp.Min"/> (min(T₁, T₂))</term>
                <description>Best-case/early exit analysis</description>
              </item>
            </list>
            <para>
            <b>Simplification Rules:</b>
            </para>
            <code>
            O(n) + O(n²) = O(n²)           // Max dominates in addition
            O(n) × O(m) = O(n·m)           // Multiplication combines
            max(O(n), O(n²)) = O(n²)       // Max selects dominant
            O(1) × O(f(n)) = O(f(n))       // Identity for multiplication
            </code>
            </remarks>
            <param name="Left">Left operand expression.</param>
            <param name="Operation">The binary operation to perform.</param>
            <param name="Right">Right operand expression.</param>
            <seealso cref="T:ComplexityAnalysis.Core.Complexity.BinaryOp"/>
            <seealso cref="T:ComplexityAnalysis.Core.Complexity.ComplexityComposition"/>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.BinaryOperationComplexity.#ctor(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.BinaryOp,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Binary operation on complexity expressions for compositional analysis.
            </summary>
            <remarks>
            <para>
            Binary operations form the backbone of complexity composition, mapping code
            structure to complexity algebra:
            </para>
            <list type="table">
              <listheader>
                <term>Operation</term>
                <description>Code Pattern</description>
              </listheader>
              <item>
                <term><see cref="F:ComplexityAnalysis.Core.Complexity.BinaryOp.Plus"/> (T₁ + T₂)</term>
                <description>Sequential code blocks: <c>loop1(); loop2();</c></description>
              </item>
              <item>
                <term><see cref="F:ComplexityAnalysis.Core.Complexity.BinaryOp.Multiply"/> (T₁ × T₂)</term>
                <description>Nested loops: <c>for(...) { for(...) { } }</c></description>
              </item>
              <item>
                <term><see cref="F:ComplexityAnalysis.Core.Complexity.BinaryOp.Max"/> (max(T₁, T₂))</term>
                <description>Branching: <c>if(cond) { slow } else { fast }</c></description>
              </item>
              <item>
                <term><see cref="F:ComplexityAnalysis.Core.Complexity.BinaryOp.Min"/> (min(T₁, T₂))</term>
                <description>Best-case/early exit analysis</description>
              </item>
            </list>
            <para>
            <b>Simplification Rules:</b>
            </para>
            <code>
            O(n) + O(n²) = O(n²)           // Max dominates in addition
            O(n) × O(m) = O(n·m)           // Multiplication combines
            max(O(n), O(n²)) = O(n²)       // Max selects dominant
            O(1) × O(f(n)) = O(f(n))       // Identity for multiplication
            </code>
            </remarks>
            <param name="Left">Left operand expression.</param>
            <param name="Operation">The binary operation to perform.</param>
            <param name="Right">Right operand expression.</param>
            <seealso cref="T:ComplexityAnalysis.Core.Complexity.BinaryOp"/>
            <seealso cref="T:ComplexityAnalysis.Core.Complexity.ComplexityComposition"/>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.BinaryOperationComplexity.Left">
            <summary>Left operand expression.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.BinaryOperationComplexity.Operation">
            <summary>The binary operation to perform.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.BinaryOperationComplexity.Right">
            <summary>Right operand expression.</summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.BinaryOp">
            <summary>
            Binary operations for composing complexity expressions.
            </summary>
            <remarks>
            These operations model how code structure translates to complexity composition:
            <list type="bullet">
              <item><description><c>Plus</c>: Sequential execution (loop₁; loop₂)</description></item>
              <item><description><c>Multiply</c>: Nested execution (for { for { } })</description></item>
              <item><description><c>Max</c>: Worst-case branching (if-else)</description></item>
              <item><description><c>Min</c>: Best-case / early exit</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.BinaryOp.Plus">
            <summary>
            Addition: T₁ + T₂ (sequential composition).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.BinaryOp.Multiply">
            <summary>
            Multiplication: T₁ × T₂ (nested composition).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.BinaryOp.Max">
            <summary>
            Maximum: max(T₁, T₂) (branching/worst case).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.BinaryOp.Min">
            <summary>
            Minimum: min(T₁, T₂) (best case/early exit).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ConditionalComplexity">
            <summary>
            Conditional complexity: represents different complexities based on runtime conditions.
            </summary>
            <remarks>
            <para>
            Models code branches where different paths have different complexities:
            </para>
            <code>
            if (isSorted) {
                BinarySearch();     // O(log n)
            } else {
                LinearSearch();     // O(n)
            }
            // → ConditionalComplexity("isSorted", O(log n), O(n))
            </code>
            <para>
            <b>Evaluation Strategy:</b> For worst-case analysis, <see cref="M:ComplexityAnalysis.Core.Complexity.ConditionalComplexity.Evaluate(System.Collections.Generic.IReadOnlyDictionary{ComplexityAnalysis.Core.Complexity.Variable,System.Double})"/>
            conservatively returns max(TrueBranch, FalseBranch). For best-case or
            average-case analysis, see the speculative analysis infrastructure.
            </para>
            </remarks>
            <param name="ConditionDescription">Human-readable description of the condition.</param>
            <param name="TrueBranch">Complexity when condition is true.</param>
            <param name="FalseBranch">Complexity when condition is false.</param>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ConditionalComplexity.#ctor(System.String,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Conditional complexity: represents different complexities based on runtime conditions.
            </summary>
            <remarks>
            <para>
            Models code branches where different paths have different complexities:
            </para>
            <code>
            if (isSorted) {
                BinarySearch();     // O(log n)
            } else {
                LinearSearch();     // O(n)
            }
            // → ConditionalComplexity("isSorted", O(log n), O(n))
            </code>
            <para>
            <b>Evaluation Strategy:</b> For worst-case analysis, <see cref="M:ComplexityAnalysis.Core.Complexity.ConditionalComplexity.Evaluate(System.Collections.Generic.IReadOnlyDictionary{ComplexityAnalysis.Core.Complexity.Variable,System.Double})"/>
            conservatively returns max(TrueBranch, FalseBranch). For best-case or
            average-case analysis, see the speculative analysis infrastructure.
            </para>
            </remarks>
            <param name="ConditionDescription">Human-readable description of the condition.</param>
            <param name="TrueBranch">Complexity when condition is true.</param>
            <param name="FalseBranch">Complexity when condition is false.</param>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ConditionalComplexity.ConditionDescription">
            <summary>Human-readable description of the condition.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ConditionalComplexity.TrueBranch">
            <summary>Complexity when condition is true.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ConditionalComplexity.FalseBranch">
            <summary>Complexity when condition is false.</summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.PowerComplexity">
            <summary>
            Power of a complexity expression: expr^k.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.PowerComplexity.#ctor(ComplexityAnalysis.Core.Complexity.ComplexityExpression,System.Double)">
            <summary>
            Power of a complexity expression: expr^k.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.LogOfComplexity">
            <summary>
            Logarithm of a complexity expression: log(expr).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.LogOfComplexity.#ctor(ComplexityAnalysis.Core.Complexity.ComplexityExpression,System.Double)">
            <summary>
            Logarithm of a complexity expression: log(expr).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ExponentialOfComplexity">
            <summary>
            Exponential of a complexity expression: base^expr.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ExponentialOfComplexity.#ctor(System.Double,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Exponential of a complexity expression: base^expr.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.FactorialOfComplexity">
            <summary>
            Factorial of a complexity expression: expr!.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.FactorialOfComplexity.#ctor(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Factorial of a complexity expression: expr!.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.SourceType">
            <summary>
            The type of source for a complexity claim.
            Ordered from most to least authoritative.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.SourceType.Documented">
            <summary>
            Documented in official Microsoft docs with explicit complexity.
            Highest confidence.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.SourceType.Attested">
            <summary>
            Attested in academic papers, CLRS, or other authoritative sources.
            High confidence.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.SourceType.Empirical">
            <summary>
            Measured via benchmarking with verification.
            Good confidence, but environment-dependent.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.SourceType.Inferred">
            <summary>
            Inferred from source code analysis.
            Medium confidence.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.SourceType.Heuristic">
            <summary>
            Conservative estimate when exact complexity is unknown.
            Prefer overestimate to underestimate.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.SourceType.Unknown">
            <summary>
            Unknown source or unverified claim.
            Lowest confidence.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ComplexitySource">
            <summary>
            Records the source and confidence level for a complexity claim.
            Essential for audit trails and conservative estimation.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ComplexitySource.Type">
            <summary>
            The type of source for this complexity claim.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ComplexitySource.Citation">
            <summary>
            Citation or reference for the source.
            Examples:
            - URL to Microsoft docs
            - "CLRS 4th ed., Chapter 7"
            - "Measured via BenchmarkDotNet"
            - "Conservative estimate: worst-case resize"
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ComplexitySource.Confidence">
            <summary>
            Confidence level in the claim (0.0 to 1.0).
            - 1.0: Certain (documented, verified)
            - 0.8-0.9: High confidence (attested, empirical)
            - 0.5-0.7: Medium confidence (inferred, heuristic)
            - &lt;0.5: Low confidence (uncertain)
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ComplexitySource.IsUpperBound">
            <summary>
            Whether this is an upper bound (conservative overestimate).
            When true, actual complexity may be lower.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ComplexitySource.IsAmortized">
            <summary>
            Whether this is an amortized complexity.
            Individual operations may exceed this bound.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ComplexitySource.IsWorstCase">
            <summary>
            Whether this complexity is for the worst case.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ComplexitySource.Notes">
            <summary>
            Optional notes about edge cases or assumptions.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ComplexitySource.LastVerified">
            <summary>
            Date the source was last verified (if applicable).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexitySource.FromMicrosoftDocs(System.String,System.String)">
            <summary>
            Creates a documented source from Microsoft docs.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexitySource.FromAcademic(System.String,System.Double)">
            <summary>
            Creates an attested source from academic literature.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexitySource.FromBenchmark(System.String,System.Double)">
            <summary>
            Creates an empirical source from benchmarking.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexitySource.Inferred(System.String,System.Double)">
            <summary>
            Creates an inferred source from code analysis.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexitySource.ConservativeHeuristic(System.String,System.Double)">
            <summary>
            Creates a conservative heuristic estimate.
            Always marks as upper bound.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexitySource.Unknown">
            <summary>
            Creates an unknown source (used when no information is available).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexitySource.Documented(System.String)">
            <summary>
            Creates a documented source with citation.
            Shorthand for BCL mapping declarations.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexitySource.Attested(System.String)">
            <summary>
            Creates an attested source with citation.
            Shorthand for BCL mapping declarations.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexitySource.Empirical(System.String)">
            <summary>
            Creates an empirical source with description.
            Shorthand for BCL mapping declarations.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexitySource.Heuristic(System.String)">
            <summary>
            Creates a heuristic source with reasoning.
            Shorthand for BCL mapping declarations.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.AttributedComplexity">
            <summary>
            A complexity expression paired with its source attribution.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.AttributedComplexity.Expression">
            <summary>
            The complexity expression.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.AttributedComplexity.Source">
            <summary>
            The source of the complexity claim.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.AttributedComplexity.RequiresReview">
            <summary>
            Whether this result requires human review.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.AttributedComplexity.ReviewReason">
            <summary>
            Reason for requiring review (if applicable).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.AttributedComplexity.Documented(ComplexityAnalysis.Core.Complexity.ComplexityExpression,System.String,System.String)">
            <summary>
            Creates an attributed complexity from documented source.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.AttributedComplexity.Attested(ComplexityAnalysis.Core.Complexity.ComplexityExpression,System.String)">
            <summary>
            Creates an attributed complexity from academic source.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.AttributedComplexity.Heuristic(ComplexityAnalysis.Core.Complexity.ComplexityExpression,System.String)">
            <summary>
            Creates a conservative heuristic complexity.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ComplexityResult">
            <summary>
            Complete result of complexity analysis for a method or code block.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ComplexityResult.Expression">
            <summary>
            The computed complexity expression.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ComplexityResult.Source">
            <summary>
            Source attribution for the complexity claim.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ComplexityResult.RequiresReview">
            <summary>
            Whether this result requires human review.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ComplexityResult.ReviewReason">
            <summary>
            Reason for requiring review (if applicable).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ComplexityResult.Location">
            <summary>
            Location in source code where this complexity was computed.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ComplexityResult.SubResults">
            <summary>
            Sub-results that contributed to this complexity.
            Useful for explaining how the total was derived.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityResult.Create(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexitySource,ComplexityAnalysis.Core.Complexity.SourceLocation)">
            <summary>
            Creates a result with automatic review flagging based on source.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.SourceLocation">
            <summary>
            Location in source code.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.SourceLocation.FilePath">
            <summary>
            File path.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.SourceLocation.StartLine">
            <summary>
            Starting line number (1-based).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.SourceLocation.StartColumn">
            <summary>
            Starting column (0-based).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.SourceLocation.EndLine">
            <summary>
            Ending line number (1-based).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.SourceLocation.EndColumn">
            <summary>
            Ending column (0-based).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ExpressionForm">
            <summary>
            Classifies the dominant asymptotic form of complexity expressions.
            Essential for determining theorem applicability.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ExpressionForm.Constant">
            <summary>O(1) - constant complexity.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ExpressionForm.Logarithmic">
            <summary>O(log^k n) - pure logarithmic (no polynomial factor).</summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ExpressionForm.Polynomial">
            <summary>O(n^k) - pure polynomial.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ExpressionForm.PolyLog">
            <summary>O(n^k · log^j n) - polylogarithmic.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ExpressionForm.Exponential">
            <summary>O(k^n) - exponential.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ExpressionForm.Factorial">
            <summary>O(n!) - factorial.</summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ExpressionForm.Unknown">
            <summary>Cannot be classified into standard forms.</summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ExpressionClassification">
            <summary>
            Result of classifying an expression's asymptotic form.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ExpressionClassification.Form">
            <summary>The dominant asymptotic form.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ExpressionClassification.Variable">
            <summary>The variable the classification is with respect to.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ExpressionClassification.PrimaryParameter">
            <summary>
            For Polynomial/PolyLog: the polynomial degree k in n^k.
            For Logarithmic: 0.
            For Exponential: the base.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ExpressionClassification.LogExponent">
            <summary>
            For PolyLog/Logarithmic: the log exponent j in log^j n.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ExpressionClassification.Coefficient">
            <summary>
            Leading coefficient (preserved for non-asymptotic analysis).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ExpressionClassification.Confidence">
            <summary>
            Confidence level in the classification (0.0 to 1.0).
            Lower for complex composed expressions.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ExpressionClassification.ToPolyLog">
            <summary>
            Converts to a normalized PolyLogComplexity if applicable.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ExpressionClassification.CompareDegreeTo(System.Double,System.Double)">
            <summary>
            Compares the polynomial degree to a target value.
            Returns: &lt;0 if degree &lt; target, 0 if equal (within epsilon), &gt;0 if degree &gt; target.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.IExpressionClassifier">
            <summary>
            Interface for classifying complexity expressions into standard forms.
            Used to determine theorem applicability.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.IExpressionClassifier.Classify(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Classifies the dominant asymptotic form of an expression.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.IExpressionClassifier.TryExtractPolynomialDegree(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,System.Double@)">
            <summary>
            Attempts to extract polynomial degree if expression is O(n^k).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.IExpressionClassifier.TryExtractPolyLogForm(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,System.Double@,System.Double@)">
            <summary>
            Attempts to extract polylog form parameters if expression is O(n^k · log^j n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.IExpressionClassifier.IsBoundedByPolynomial(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
            <summary>
            Determines if expression is bounded by O(n^d) for given d.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.IExpressionClassifier.DominatesPolynomial(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,System.Double)">
            <summary>
            Determines if expression dominates Ω(n^d) for given d.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.StandardExpressionClassifier">
            <summary>
            Standard implementation of expression classification.
            Uses pattern matching and visitor traversal.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.IComplexityTransformer">
            <summary>
            Interface for transforming and simplifying complexity expressions.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.IComplexityTransformer.Simplify(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Simplify an expression by applying algebraic rules.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.IComplexityTransformer.NormalizeForm(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Normalize to a canonical form for comparison.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.IComplexityTransformer.DropConstantFactors(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Drop constant factors for Big-O equivalence.
            O(3n²) → O(n²)
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.IComplexityTransformer.DropLowerOrderTerms(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Drop lower-order terms for asymptotic equivalence.
            O(n² + n + 1) → O(n²)
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.IComplexityComparator">
            <summary>
            Compares complexity expressions for asymptotic ordering.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.IComplexityComparator.Compare(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Compare two expressions asymptotically.
            Returns: -1 if left &lt; right, 0 if equal, 1 if left > right.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.IComplexityComparator.IsDominated(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Determines if left is dominated by right (left ∈ O(right)).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.IComplexityComparator.AreEquivalent(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Determines if two expressions are asymptotically equivalent.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ComplexitySimplifier">
            <summary>
            Standard implementation of complexity simplification.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexitySimplifier.Simplify(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <inheritdoc />
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexitySimplifier.NormalizeForm(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <inheritdoc />
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexitySimplifier.DropConstantFactors(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <inheritdoc />
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexitySimplifier.DropLowerOrderTerms(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <inheritdoc />
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.AsymptoticComparator">
            <summary>
            Compares complexity expressions by asymptotic growth rate.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.AsymptoticComparator.Compare(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Asymptotic ordering (from slowest to fastest growth):
            O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n²) &lt; O(n³) &lt; O(2ⁿ) &lt; O(n!)
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.AsymptoticComparator.IsDominated(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <inheritdoc />
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.AsymptoticComparator.AreEquivalent(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <inheritdoc />
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.AsymptoticComparator.GetAsymptoticOrder(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Gets a numeric order for asymptotic comparison.
            Higher values = faster growth.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ComplexityExpressionExtensions">
            <summary>
            Extension methods for complexity expressions.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityExpressionExtensions.Simplified(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Simplifies the expression using the default simplifier.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityExpressionExtensions.Normalized(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Normalizes to canonical Big-O form.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityExpressionExtensions.CompareAsymptotically(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Compares asymptotically to another expression.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityExpressionExtensions.IsDominatedBy(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Checks if this expression is dominated by another.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ComplexityExpressionExtensions.Dominates(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Checks if this expression dominates another.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.IComplexityVisitor`1">
            <summary>
            Visitor pattern interface for traversing complexity expression trees.
            Enables operations like simplification, evaluation, and transformation.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.IComplexityVisitor`1.VisitUnknown(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Fallback for unknown/unrecognized expression types (e.g., special functions).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ComplexityVisitorBase`1">
            <summary>
            Base implementation of IComplexityVisitor that returns default values.
            Override specific methods to handle particular expression types.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ComplexityTransformVisitor">
            <summary>
            Visitor that recursively transforms complexity expressions.
            Override methods to modify specific node types during traversal.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ParallelComplexity">
            <summary>
            Represents complexity of parallel/concurrent algorithms.
            
            Parallel complexity considers:
            - Work: Total operations across all processors (sequential equivalent)
            - Span/Depth: Longest chain of dependent operations (critical path)
            - Parallelism: Work / Span ratio (how parallelizable the algorithm is)
            
            Examples:
            - Parallel.For over n items: Work O(n), Span O(1) if independent
            - Parallel merge sort: Work O(n log n), Span O(log² n)
            - Parallel prefix sum: Work O(n), Span O(log n)
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelComplexity.Work">
            <summary>
            Total work across all processors (sequential time complexity).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelComplexity.Span">
            <summary>
            Span/depth - the longest chain of dependent operations.
            Also known as critical path length.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelComplexity.ProcessorCount">
            <summary>
            Number of processors/cores assumed.
            Use Variable.P for parameterized, or a constant for fixed.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelComplexity.PatternType">
            <summary>
            The type of parallel pattern detected.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelComplexity.IsTaskBased">
            <summary>
            Whether the parallelism is task-based (async/await, Task.Run).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelComplexity.HasSynchronizationOverhead">
            <summary>
            Whether the parallel operations have synchronization overhead.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelComplexity.Description">
            <summary>
            Description of the parallel pattern.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelComplexity.Parallelism">
            <summary>
            Gets the parallelism (Work / Span ratio).
            Higher values indicate better parallelizability.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelComplexity.ParallelTime">
            <summary>
            Gets the parallel time (with p processors): max(Work/p, Span).
            By Brent's theorem: T_p ≤ (Work - Span)/p + Span
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ParallelComplexity.EmbarrassinglyParallel(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates a parallel complexity for embarrassingly parallel work.
            Work = O(n), Span = O(1).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ParallelComplexity.Reduction(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates parallel complexity for reduction/aggregation patterns.
            Work = O(n), Span = O(log n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ParallelComplexity.DivideAndConquer(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates parallel complexity for divide-and-conquer patterns.
            Work = O(n log n), Span = O(log² n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ParallelComplexity.PrefixScan(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates parallel complexity for prefix/scan operations.
            Work = O(n), Span = O(log n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ParallelComplexity.Pipeline(ComplexityAnalysis.Core.Complexity.Variable,System.Int32)">
            <summary>
            Creates parallel complexity for pipeline patterns.
            Work = O(n × stages), Span = O(n + stages).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ParallelComplexity.TaskBased(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression,System.String)">
            <summary>
            Creates complexity for async/await task-based concurrency.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ParallelPatternType">
            <summary>
            Types of parallel patterns.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ParallelPatternType.Generic">
            <summary>
            Generic parallel pattern.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ParallelPatternType.ParallelFor">
            <summary>
            Parallel.For / Parallel.ForEach - data parallelism.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ParallelPatternType.PLINQ">
            <summary>
            PLINQ - parallel LINQ.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ParallelPatternType.TaskBased">
            <summary>
            Task.Run / Task.WhenAll - task parallelism.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ParallelPatternType.AsyncAwait">
            <summary>
            async/await patterns.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ParallelPatternType.Reduction">
            <summary>
            Parallel reduction/aggregation.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ParallelPatternType.Scan">
            <summary>
            Parallel prefix scan.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ParallelPatternType.DivideAndConquer">
            <summary>
            Divide-and-conquer parallelism.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ParallelPatternType.Pipeline">
            <summary>
            Pipeline parallelism.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ParallelPatternType.ForkJoin">
            <summary>
            Fork-join pattern.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ParallelPatternType.ProducerConsumer">
            <summary>
            Producer-consumer pattern.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ParallelVariables">
            <summary>
            Variable for processor count.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelVariables.P">
            <summary>
            Number of processors (p).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ParallelVariables.Processors(System.Int32)">
            <summary>
            Creates a processor count variable with a specific value.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelVariables.InfiniteProcessors">
            <summary>
            Infinite processors (theoretical analysis).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.IParallelComplexityVisitor`1">
            <summary>
            Extended visitor interface for parallel complexity.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ParallelAnalysisResult">
            <summary>
            Analysis result for parallel patterns.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelAnalysisResult.Complexity">
            <summary>
            The detected parallel complexity.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelAnalysisResult.Speedup">
            <summary>
            Speedup factor: T_1 / T_p (sequential time / parallel time).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelAnalysisResult.Efficiency">
            <summary>
            Efficiency: Speedup / p (how well processors are utilized).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelAnalysisResult.IsScalable">
            <summary>
            Whether the pattern has good scalability.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelAnalysisResult.Warnings">
            <summary>
            Potential issues or warnings.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ParallelAnalysisResult.Recommendations">
            <summary>
            Recommendations for improving parallelism.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ParallelAlgorithms">
            <summary>
            Common parallel algorithm complexities.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ParallelAlgorithms.ParallelSum">
            <summary>
            Parallel sum/reduction: Work O(n), Span O(log n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ParallelAlgorithms.ParallelMergeSort">
            <summary>
            Parallel merge sort: Work O(n log n), Span O(log² n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ParallelAlgorithms.ParallelMatrixMultiply">
            <summary>
            Parallel matrix multiply (naive): Work O(n³), Span O(log n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ParallelAlgorithms.ParallelQuickSort">
            <summary>
            Parallel quick sort: Work O(n log n), Span O(log² n) expected.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ParallelAlgorithms.ParallelBFS">
            <summary>
            Parallel BFS: Work O(V + E), Span O(diameter × log V).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ParallelAlgorithms.PLINQFilter">
            <summary>
            PLINQ Where/Select: Work O(n), Span O(n/p + log p).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.PolyLogComplexity">
            <summary>
            Represents polylogarithmic complexity: O(n^k · log^j n).
            </summary>
            <remarks>
            <para>
            <b>General Form:</b> coefficient · n^polyDegree · (log_base n)^logExponent
            </para>
            <para>
            This unified type is essential for representing many common complexity classes:
            </para>
            
            <list type="table">
              <listheader>
                <term>Parameters</term>
                <description>Result</description>
              </listheader>
              <item>
                <term>k=1, j=1</term>
                <description>O(n log n) - Merge sort, heap sort, optimal comparison sorts</description>
              </item>
              <item>
                <term>k=2, j=0</term>
                <description>O(n²) - Pure polynomial (quadratic)</description>
              </item>
              <item>
                <term>k=0, j=1</term>
                <description>O(log n) - Pure logarithmic (binary search)</description>
              </item>
              <item>
                <term>k=1, j=2</term>
                <description>O(n log² n) - Some advanced algorithms</description>
              </item>
              <item>
                <term>k=0, j=2</term>
                <description>O(log² n) - Iterated binary search</description>
              </item>
            </list>
            
            <para>
            <b>Master Theorem Connection:</b>
            </para>
            <para>
            Case 2 of the Master Theorem produces polylog solutions. For T(n) = a·T(n/b) + Θ(n^d · log^k n)
            where d = log_b(a):
            </para>
            <code>
            T(n) = Θ(n^d · log^(k+1) n)
            </code>
            <para>
            The factory method <see cref="M:ComplexityAnalysis.Core.Complexity.PolyLogComplexity.MasterCase2Solution(System.Double,System.Double,ComplexityAnalysis.Core.Complexity.Variable)"/> creates these solutions directly.
            </para>
            
            <para>
            <b>Algebraic Properties:</b>
            </para>
            <code>
            // Multiplication combines exponents:
            (n^a log^b n) × (n^c log^d n) = n^(a+c) · log^(b+d) n
            
            // Power distributes:
            (n^a log^b n)^k = n^(ak) · log^(bk) n
            </code>
            </remarks>
            <seealso cref="T:ComplexityAnalysis.Core.Complexity.PolynomialComplexity"/>
            <seealso cref="T:ComplexityAnalysis.Core.Complexity.LogarithmicComplexity"/>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.PolyLogComplexity.#ctor(System.Double,System.Double,ComplexityAnalysis.Core.Complexity.Variable,System.Double,System.Double)">
            <summary>
            Represents polylogarithmic complexity: O(n^k · log^j n).
            </summary>
            <remarks>
            <para>
            <b>General Form:</b> coefficient · n^polyDegree · (log_base n)^logExponent
            </para>
            <para>
            This unified type is essential for representing many common complexity classes:
            </para>
            
            <list type="table">
              <listheader>
                <term>Parameters</term>
                <description>Result</description>
              </listheader>
              <item>
                <term>k=1, j=1</term>
                <description>O(n log n) - Merge sort, heap sort, optimal comparison sorts</description>
              </item>
              <item>
                <term>k=2, j=0</term>
                <description>O(n²) - Pure polynomial (quadratic)</description>
              </item>
              <item>
                <term>k=0, j=1</term>
                <description>O(log n) - Pure logarithmic (binary search)</description>
              </item>
              <item>
                <term>k=1, j=2</term>
                <description>O(n log² n) - Some advanced algorithms</description>
              </item>
              <item>
                <term>k=0, j=2</term>
                <description>O(log² n) - Iterated binary search</description>
              </item>
            </list>
            
            <para>
            <b>Master Theorem Connection:</b>
            </para>
            <para>
            Case 2 of the Master Theorem produces polylog solutions. For T(n) = a·T(n/b) + Θ(n^d · log^k n)
            where d = log_b(a):
            </para>
            <code>
            T(n) = Θ(n^d · log^(k+1) n)
            </code>
            <para>
            The factory method <see cref="M:ComplexityAnalysis.Core.Complexity.PolyLogComplexity.MasterCase2Solution(System.Double,System.Double,ComplexityAnalysis.Core.Complexity.Variable)"/> creates these solutions directly.
            </para>
            
            <para>
            <b>Algebraic Properties:</b>
            </para>
            <code>
            // Multiplication combines exponents:
            (n^a log^b n) × (n^c log^d n) = n^(a+c) · log^(b+d) n
            
            // Power distributes:
            (n^a log^b n)^k = n^(ak) · log^(bk) n
            </code>
            </remarks>
            <seealso cref="T:ComplexityAnalysis.Core.Complexity.PolynomialComplexity"/>
            <seealso cref="T:ComplexityAnalysis.Core.Complexity.LogarithmicComplexity"/>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.PolyLogComplexity.IsPurePolynomial">
            <summary>
            True if this is a pure polynomial (no log factor).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.PolyLogComplexity.IsPureLogarithmic">
            <summary>
            True if this is a pure logarithmic (no polynomial factor).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.PolyLogComplexity.IsNLogN">
            <summary>
            True if this is the common n log n form.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.PolyLogComplexity.NLogN(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates O(n log n) - common for efficient sorting/divide-and-conquer.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.PolyLogComplexity.PolyTimesLog(System.Double,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates O(n^k log n) - Master Theorem Case 2 with k=1.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.PolyLogComplexity.MasterCase2Solution(System.Double,System.Double,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates O(n^d · log^(k+1) n) - General Master Theorem Case 2 solution.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.PolyLogComplexity.LogPower(System.Double,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates O(log^k n) - pure iterated logarithm.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.PolyLogComplexity.Polynomial(System.Double,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates O(n^k) - pure polynomial (for consistency).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.PolyLogComplexity.Multiply(ComplexityAnalysis.Core.Complexity.PolyLogComplexity)">
            <summary>
            Multiplies two PolyLog expressions: (n^a log^b n) × (n^c log^d n) = n^(a+c) log^(b+d) n
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.PolyLogComplexity.Power(System.Double)">
            <summary>
            Raises to a power: (n^a log^b n)^k = n^(ak) log^(bk) n
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.RandomnessSource">
            <summary>
            Specifies the source of randomness in a probabilistic algorithm.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.RandomnessSource.InputDistribution">
            <summary>
            Randomness comes from the input distribution (average-case analysis).
            Example: QuickSort with random input permutation.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.RandomnessSource.AlgorithmRandomness">
            <summary>
            Randomness comes from the algorithm itself (Las Vegas algorithms).
            Example: Randomized QuickSort with random pivot selection.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.RandomnessSource.MonteCarlo">
            <summary>
            Monte Carlo algorithms that may produce incorrect results with small probability.
            Example: Miller-Rabin primality test.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.RandomnessSource.HashFunction">
            <summary>
            Hash function randomness (universal hashing, expected behavior).
            Example: Hash table operations assuming uniform hashing.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.RandomnessSource.Mixed">
            <summary>
            Multiple sources of randomness combined.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ProbabilityDistribution">
            <summary>
            Specifies the probability distribution of the complexity.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ProbabilityDistribution.Uniform">
            <summary>
            Uniform distribution over all inputs.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ProbabilityDistribution.Exponential">
            <summary>
            Exponential distribution (common in queueing theory).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ProbabilityDistribution.Geometric">
            <summary>
            Geometric distribution (common in randomized algorithms).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ProbabilityDistribution.HighProbabilityBound">
            <summary>
            Bounded/concentrated distribution with high probability guarantees.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ProbabilityDistribution.InputDependent">
            <summary>
            Distribution determined by specific input characteristics.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.ProbabilityDistribution.Unknown">
            <summary>
            Unknown or unspecified distribution.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity">
            <summary>
            Represents probabilistic complexity analysis for randomized algorithms.
            Captures expected (average), best-case, and worst-case complexities along with
            probability distribution information.
            </summary>
            <remarks>
            This is used for analyzing:
            - Average-case complexity (QuickSort, hash tables)
            - Randomized algorithms (randomized QuickSort, randomized selection)
            - Monte Carlo algorithms (primality testing)
            - Las Vegas algorithms (randomized algorithms that always produce correct results)
            </remarks>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.ExpectedComplexity">
            <summary>
            Gets the expected (average-case) complexity.
            This represents E[T(n)] - the expected running time.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.WorstCaseComplexity">
            <summary>
            Gets the worst-case complexity.
            This is the upper bound that holds for all inputs/random choices.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.BestCaseComplexity">
            <summary>
            Gets the best-case complexity.
            Optional - when not specified, defaults to constant.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.Source">
            <summary>
            Gets the source of randomness in the algorithm.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.Distribution">
            <summary>
            Gets the probability distribution of the complexity.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.Variance">
            <summary>
            Gets the variance of the complexity if known.
            Null indicates unknown variance.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.HighProbability">
            <summary>
            Gets the high-probability bound if applicable.
            For algorithms with concentration bounds: Pr[T(n) > bound] ≤ probability.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.Assumptions">
            <summary>
            Gets any assumptions required for the expected complexity to hold.
            Example: "uniform random input permutation", "independent hash function"
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.Description">
            <summary>
            Gets an optional description of the probabilistic analysis.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.Accept``1(ComplexityAnalysis.Core.Complexity.IComplexityVisitor{``0})">
            <inheritdoc />
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.Substitute(ComplexityAnalysis.Core.Complexity.Variable,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <inheritdoc />
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.FreeVariables">
            <inheritdoc />
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.Evaluate(System.Collections.Generic.IReadOnlyDictionary{ComplexityAnalysis.Core.Complexity.Variable,System.Double})">
            <inheritdoc />
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.ToBigONotation">
            <inheritdoc />
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.QuickSortLike(ComplexityAnalysis.Core.Complexity.Variable,ComplexityAnalysis.Core.Complexity.RandomnessSource)">
            <summary>
            Creates a probabilistic complexity with expected O(n log n) and worst O(n²).
            Common for randomized sorting algorithms like QuickSort.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.HashTableLookup(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates a probabilistic complexity for hash table operations.
            Expected O(1), worst O(n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.RandomizedSelection(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates a probabilistic complexity for randomized selection (Quickselect).
            Expected O(n), worst O(n²).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.SkipListOperation(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates a probabilistic complexity for skip list operations.
            Expected O(log n), worst O(n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.BloomFilterLookup(System.Int32)">
            <summary>
            Creates a probabilistic complexity for Bloom filter operations.
            O(k) where k is the number of hash functions, with false positive probability.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity.MonteCarlo(ComplexityAnalysis.Core.Complexity.ComplexityExpression,System.Double,System.String)">
            <summary>
            Creates a Monte Carlo complexity where the result may be incorrect with some probability.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.HighProbabilityBound">
            <summary>
            Represents a high-probability bound: Pr[T(n) ≤ bound] ≥ probability.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.HighProbabilityBound.Bound">
            <summary>
            Gets the complexity bound that holds with high probability.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.HighProbabilityBound.Probability">
            <summary>
            Gets the probability that the bound holds.
            For "with high probability" bounds, this is typically 1 - 1/n^c for some constant c.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.HighProbabilityBound.ProbabilityExpression">
            <summary>
            Gets an optional expression for the probability as a function of n.
            Example: 1 - 1/n for bounds that hold "with high probability".
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.IProbabilisticComplexityVisitor`1">
            <summary>
            Extension of IComplexityVisitor for probabilistic complexity.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.IProbabilisticComplexityVisitor`1.VisitProbabilistic(ComplexityAnalysis.Core.Complexity.ProbabilisticComplexity)">
            <summary>
            Visits a probabilistic complexity expression.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.SpecialFunctionComplexity">
             <summary>
             Represents special mathematical functions that arise in complexity analysis,
             particularly from Akra-Bazzi integral evaluation.
            
             These provide symbolic representations when closed-form elementary solutions
             don't exist, enabling later refinement via numerical methods or CAS integration.
             </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.SpecialFunctionComplexity.HasAsymptoticExpansion">
            <summary>
            Whether this function has a known asymptotic expansion.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.SpecialFunctionComplexity.DominantTerm">
            <summary>
            Gets the dominant asymptotic term, if known.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.PolylogarithmComplexity">
             <summary>
             Polylogarithm Li_s(z) = Σₖ₌₁^∞ z^k / k^s
            
             Arises when integrating log terms. For |z| ≤ 1:
             - Li_1(z) = -ln(1-z)
             - Li_0(z) = z/(1-z)
             - Li_{-1}(z) = z/(1-z)²
            
             For complexity analysis, we often have Li_s(1) = ζ(s) (Riemann zeta).
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.PolylogarithmComplexity.#ctor(System.Double,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
             <summary>
             Polylogarithm Li_s(z) = Σₖ₌₁^∞ z^k / k^s
            
             Arises when integrating log terms. For |z| ≤ 1:
             - Li_1(z) = -ln(1-z)
             - Li_0(z) = z/(1-z)
             - Li_{-1}(z) = z/(1-z)²
            
             For complexity analysis, we often have Li_s(1) = ζ(s) (Riemann zeta).
             </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.IncompleteGammaComplexity">
             <summary>
             Incomplete Gamma function γ(s, x) = ∫₀ˣ t^(s-1) e^(-t) dt
            
             Arises from exponential-polynomial integrals. Asymptotically:
             - For large x: γ(s, x) → Γ(s) (complete gamma)
             - For small x: γ(s, x) ≈ x^s / s
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.IncompleteGammaComplexity.#ctor(System.Double,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
             <summary>
             Incomplete Gamma function γ(s, x) = ∫₀ˣ t^(s-1) e^(-t) dt
            
             Arises from exponential-polynomial integrals. Asymptotically:
             - For large x: γ(s, x) → Γ(s) (complete gamma)
             - For small x: γ(s, x) ≈ x^s / s
             </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.IncompleteBetaComplexity">
             <summary>
             Incomplete Beta function B(x; a, b) = ∫₀ˣ t^(a-1) (1-t)^(b-1) dt
            
             Related to regularized incomplete beta I_x(a,b) = B(x;a,b) / B(a,b).
             Arises in probability and from polynomial ratio integrals.
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.IncompleteBetaComplexity.#ctor(System.Double,System.Double,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
             <summary>
             Incomplete Beta function B(x; a, b) = ∫₀ˣ t^(a-1) (1-t)^(b-1) dt
            
             Related to regularized incomplete beta I_x(a,b) = B(x;a,b) / B(a,b).
             Arises in probability and from polynomial ratio integrals.
             </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.HypergeometricComplexity">
             <summary>
             Gauss Hypergeometric function ₂F₁(a, b; c; z)
            
             The most general special function needed for Akra-Bazzi integrals.
             Many special functions are cases of ₂F₁:
             - log(1+z) = z · ₂F₁(1, 1; 2; -z)
             - arcsin(z) = z · ₂F₁(1/2, 1/2; 3/2; z²)
             - (1-z)^(-a) = ₂F₁(a, b; b; z) for any b
             </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.HypergeometricComplexity.#ctor(System.Double,System.Double,System.Double,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
             <summary>
             Gauss Hypergeometric function ₂F₁(a, b; c; z)
            
             The most general special function needed for Akra-Bazzi integrals.
             Many special functions are cases of ₂F₁:
             - log(1+z) = z · ₂F₁(1, 1; 2; -z)
             - arcsin(z) = z · ₂F₁(1/2, 1/2; 3/2; z²)
             - (1-z)^(-a) = ₂F₁(a, b; b; z) for any b
             </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.HypergeometricComplexity.SimplifiedForm">
            <summary>
            Recognizes if this hypergeometric is actually a simpler function.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.SymbolicIntegralComplexity">
            <summary>
            Represents a symbolic integral that cannot be evaluated in closed form.
            Preserves the integrand for potential later refinement.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.SymbolicIntegralComplexity.#ctor(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Represents a symbolic integral that cannot be evaluated in closed form.
            Preserves the integrand for potential later refinement.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.SymbolicIntegralComplexity.WithBound(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Creates a symbolic integral with an asymptotic bound estimate.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.ISpecialFunctionVisitor`1">
            <summary>
            Extended visitor interface for special functions.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.Variable">
            <summary>
            Represents a variable in complexity expressions (e.g., n, V, E, degree).
            </summary>
            <remarks>
            <para>
            Variables are symbolic placeholders for input sizes and algorithm parameters.
            Unlike mathematical variables, complexity variables carry semantic meaning
            through their <see cref="T:ComplexityAnalysis.Core.Complexity.VariableType"/> to enable domain-specific analysis.
            </para>
            
            <para>
            <b>Variable Semantics by Domain:</b>
            </para>
            <list type="table">
              <listheader>
                <term>Domain</term>
                <description>Common Variables</description>
              </listheader>
              <item>
                <term>General</term>
                <description><c>n</c> (input size), <c>k</c> (parameter count)</description>
              </item>
              <item>
                <term>Graphs</term>
                <description><c>V</c> (vertices), <c>E</c> (edges), with relationship E ≤ V²</description>
              </item>
              <item>
                <term>Trees</term>
                <description><c>n</c> (nodes), <c>h</c> (height), with h ∈ [log n, n]</description>
              </item>
              <item>
                <term>Strings</term>
                <description><c>n</c> (text length), <c>m</c> (pattern length)</description>
              </item>
              <item>
                <term>Parallel</term>
                <description><c>n</c> (work), <c>p</c> (processors)</description>
              </item>
            </list>
            
            <para>
            <b>Multi-Variable Complexity:</b> Many algorithms have complexity dependent on
            multiple variables. The system supports this through expression composition:
            </para>
            <code>
            // Graph algorithm: O(V + E)
            var graphComplexity = new BinaryOperationComplexity(
                new VariableComplexity(Variable.V),
                BinaryOp.Plus,
                new VariableComplexity(Variable.E));
                
            // String matching: O(n × m)
            var stringComplexity = new BinaryOperationComplexity(
                new VariableComplexity(Variable.N),
                BinaryOp.Multiply,
                new VariableComplexity(Variable.M));
            </code>
            
            <para>
            <b>Implicit Relationships:</b> Some variables have implicit constraints:
            </para>
            <list type="bullet">
              <item><description>In connected graphs: E ≥ V - 1</description></item>
              <item><description>In simple graphs: E ≤ V(V-1)/2</description></item>
              <item><description>In balanced trees: h = Θ(log n)</description></item>
              <item><description>In linked structures: h ≤ n</description></item>
            </list>
            </remarks>
            <seealso cref="T:ComplexityAnalysis.Core.Complexity.VariableType"/>
            <seealso cref="T:ComplexityAnalysis.Core.Complexity.VariableComplexity"/>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.Variable.Name">
            <summary>
            The symbolic name of the variable (e.g., "n", "V", "E").
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.Variable.Type">
            <summary>
            The semantic type of the variable, indicating what it represents.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.Variable.Description">
            <summary>
            Optional description for documentation purposes.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.Variable.N">
            <summary>
            Creates a standard input size variable named "n".
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.Variable.V">
            <summary>
            Creates a vertex count variable named "V".
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.Variable.E">
            <summary>
            Creates an edge count variable named "E".
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.Variable.M">
            <summary>
            Creates a secondary size variable named "m" (e.g., for pattern length in string search).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.Variable.K">
            <summary>
            Creates a count parameter variable named "k" (e.g., for Take(k), top-k queries).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.Variable.H">
            <summary>
            Creates a height/depth variable named "h" (e.g., for tree height).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Complexity.Variable.P">
            <summary>
            Creates a processor count variable named "p" (for parallel complexity).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.VariableType">
            <summary>
            Semantic types for complexity variables, indicating what the variable represents.
            </summary>
            <remarks>
            <para>
            Variable types enable semantic analysis and validation. For example, the analyzer
            can verify that graph algorithms use <see cref="F:ComplexityAnalysis.Core.Complexity.VariableType.VertexCount"/> and <see cref="F:ComplexityAnalysis.Core.Complexity.VariableType.EdgeCount"/>
            appropriately, or flag potential issues when tree algorithms don't account for
            <see cref="F:ComplexityAnalysis.Core.Complexity.VariableType.TreeHeight"/>.
            </para>
            <para>
            <b>Type Relationships:</b>
            </para>
            <list type="bullet">
              <item><description><see cref="F:ComplexityAnalysis.Core.Complexity.VariableType.VertexCount"/> and <see cref="F:ComplexityAnalysis.Core.Complexity.VariableType.EdgeCount"/> often appear together: O(V + E)</description></item>
              <item><description><see cref="F:ComplexityAnalysis.Core.Complexity.VariableType.InputSize"/> is the default for general algorithms</description></item>
              <item><description><see cref="F:ComplexityAnalysis.Core.Complexity.VariableType.SecondarySize"/> is used when two independent sizes matter (O(n × m))</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.VariableType.InputSize">
            <summary>
            General input size (n) - default for most algorithms.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.VariableType.DataCount">
            <summary>
            Count of data elements in a collection.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.VariableType.VertexCount">
            <summary>
            Number of vertices in a graph (V).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.VariableType.EdgeCount">
            <summary>
            Number of edges in a graph (E).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.VariableType.DegreeSum">
            <summary>
            Sum of vertex degrees in a graph.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.VariableType.TreeHeight">
            <summary>
            Height or depth of a tree structure.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.VariableType.ProcessorCount">
            <summary>
            Number of processors/cores (for parallel complexity).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.VariableType.Dimensions">
            <summary>
            Number of dimensions (for multi-dimensional algorithms).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.VariableType.StringLength">
            <summary>
            Length of a string or character sequence.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.VariableType.SecondarySize">
            <summary>
            A secondary size parameter (e.g., m in O(n × m)).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Complexity.VariableType.Custom">
            <summary>
            Custom/user-defined variable type.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Complexity.VariableExtensions">
            <summary>
            Extension methods for Variable.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.VariableExtensions.ToVariableSet(System.Collections.Generic.IEnumerable{ComplexityAnalysis.Core.Complexity.Variable})">
            <summary>
            Creates a variable set from multiple variables.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Complexity.VariableExtensions.IsGraphVariable(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Determines if a variable represents a graph-related quantity.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Memory.MemoryComplexity">
            <summary>
            Represents space/memory complexity analysis result.
            
            Space complexity measures memory usage as a function of input size.
            Components:
            - Stack space: Recursion depth, local variables
            - Heap space: Allocated objects, collections
            - Auxiliary space: Extra space beyond input
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryComplexity.TotalSpace">
            <summary>
            Total space complexity (dominant term).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryComplexity.StackSpace">
            <summary>
            Stack space complexity (recursion depth).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryComplexity.HeapSpace">
            <summary>
            Heap space complexity (allocated objects).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryComplexity.AuxiliarySpace">
            <summary>
            Auxiliary space (extra space beyond input).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryComplexity.IsInPlace">
            <summary>
            Whether the algorithm is in-place (O(1) auxiliary space).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryComplexity.IsTailRecursive">
            <summary>
            Whether tail-call optimization can reduce stack space.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryComplexity.Description">
            <summary>
            Description of memory usage pattern.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryComplexity.Allocations">
            <summary>
            Breakdown of memory allocations by source.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.MemoryComplexity.Constant">
            <summary>
            Creates O(1) constant space complexity (in-place).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.MemoryComplexity.Linear(ComplexityAnalysis.Core.Complexity.Variable,ComplexityAnalysis.Core.Memory.MemorySource)">
            <summary>
            Creates O(n) linear space complexity.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.MemoryComplexity.Logarithmic(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates O(log n) logarithmic space complexity (typical for recursion).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.MemoryComplexity.Quadratic(ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates O(n²) quadratic space complexity.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.MemoryComplexity.FromRecursion(System.Int32,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression,System.Boolean)">
            <summary>
            Creates memory complexity from recursion pattern.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Memory.MemorySource">
            <summary>
            Where memory is allocated.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemorySource.Stack">
            <summary>
            Stack allocation (local variables, recursion frames).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemorySource.Heap">
            <summary>
            Heap allocation (new objects, collections).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemorySource.Both">
            <summary>
            Both stack and heap.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Memory.AllocationInfo">
            <summary>
            Information about a specific memory allocation.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.AllocationInfo.Description">
            <summary>
            Description of what is being allocated.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.AllocationInfo.Size">
            <summary>
            The size complexity of this allocation.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.AllocationInfo.Source">
            <summary>
            Where the memory is allocated.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.AllocationInfo.TypeName">
            <summary>
            The type being allocated (if known).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.AllocationInfo.Count">
            <summary>
            How many times this allocation occurs.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.AllocationInfo.TotalSize">
            <summary>
            Total memory from this allocation.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Memory.ComplexityAnalysisResult">
            <summary>
            Combined time and space complexity result.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.ComplexityAnalysisResult.TimeComplexity">
            <summary>
            Time complexity of the algorithm.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.ComplexityAnalysisResult.SpaceComplexity">
            <summary>
            Space/memory complexity of the algorithm.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.ComplexityAnalysisResult.Name">
            <summary>
            The method or algorithm name.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.ComplexityAnalysisResult.HasTimeSpaceTradeoff">
            <summary>
            Whether time-space tradeoff is possible.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.ComplexityAnalysisResult.Notes">
            <summary>
            Notes about the analysis.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.ComplexityAnalysisResult.Confidence">
            <summary>
            Confidence in the analysis (0-1).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Memory.ComplexityAnalysisResult.CommonAlgorithms">
            <summary>
            Common algorithms with their time/space complexities.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Memory.IMemoryComplexityVisitor`1">
            <summary>
            Extended visitor interface for memory complexity types.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Memory.SpaceComplexityClass">
            <summary>
            Categories of space complexity.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.SpaceComplexityClass.Constant">
            <summary>
            O(1) - Constant space.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.SpaceComplexityClass.Logarithmic">
            <summary>
            O(log n) - Logarithmic space.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.SpaceComplexityClass.Linear">
            <summary>
            O(n) - Linear space.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.SpaceComplexityClass.Linearithmic">
            <summary>
            O(n log n) - Linearithmic space.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.SpaceComplexityClass.Quadratic">
            <summary>
            O(n²) - Quadratic space.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.SpaceComplexityClass.Cubic">
            <summary>
            O(n³) - Cubic space.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.SpaceComplexityClass.Exponential">
            <summary>
            O(2^n) - Exponential space.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.SpaceComplexityClass.Unknown">
            <summary>
            Unknown space complexity.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Memory.SpaceComplexityClassifier">
            <summary>
            Utility methods for space complexity classification.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.SpaceComplexityClassifier.Classify(ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Classifies a complexity expression into a space complexity class.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.SpaceComplexityClassifier.IsBetterThan(ComplexityAnalysis.Core.Memory.SpaceComplexityClass,ComplexityAnalysis.Core.Memory.SpaceComplexityClass)">
            <summary>
            Determines if one space complexity class is better (lower) than another.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.SpaceComplexityClassifier.GetDescription(ComplexityAnalysis.Core.Memory.SpaceComplexityClass)">
            <summary>
            Gets a human-readable description of the space complexity class.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Memory.MemoryTier">
            <summary>
            Represents the memory access tier hierarchy with associated performance weights.
            Each successive tier is approximately 1000x slower than the previous.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemoryTier.CpuCache">
            <summary>
            L1/L2 CPU cache - fastest access (~1-10 ns).
            Typical sizes: L1 64KB, L2 256KB-512KB.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemoryTier.MainMemory">
            <summary>
            Main memory (RAM) - fast but slower than cache (~100 ns).
            Typical sizes: 8GB-128GB.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemoryTier.LocalDisk">
            <summary>
            Local disk storage (SSD/HDD) - much slower (~100 µs for SSD).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemoryTier.LocalNetwork">
            <summary>
            Local network (LAN, same datacenter) - network latency (~1-10 ms).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemoryTier.FarNetwork">
            <summary>
            Far network (WAN, internet, cross-region) - high latency (~100+ ms).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Memory.MemoryTierWeights">
            <summary>
            Provides weight values for memory tier access costs.
            Uses a ~1000x compounding factor between tiers.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemoryTierWeights.CpuCache">
            <summary>
            Base weight for CPU cache access (normalized to 1).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemoryTierWeights.MainMemory">
            <summary>
            Weight for main memory access (~1000x cache).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemoryTierWeights.LocalDisk">
            <summary>
            Weight for local disk access (~1000x memory).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemoryTierWeights.LocalNetwork">
            <summary>
            Weight for local network access (~1000x disk).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemoryTierWeights.FarNetwork">
            <summary>
            Weight for far network access (~1000x local network).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemoryTierWeights.CompoundingFactor">
            <summary>
            The compounding factor between adjacent tiers.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.MemoryTierWeights.GetWeight(ComplexityAnalysis.Core.Memory.MemoryTier)">
            <summary>
            Gets the weight for a given memory tier.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.MemoryTierWeights.GetWeightByLevel(System.Int32)">
            <summary>
            Gets the weight for a tier by its ordinal level.
            Level 0 = Cache, Level 1 = Memory, etc.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryTierWeights.AllTiers">
            <summary>
            Gets all tiers and their weights.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Memory.MemoryAccess">
            <summary>
            Represents a single memory access with its tier and access count.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryAccess.Tier">
            <summary>
            The memory tier being accessed.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryAccess.AccessCount">
            <summary>
            The number of accesses (as a complexity expression).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryAccess.Description">
            <summary>
            Optional description of what this access represents.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryAccess.WeightPerAccess">
            <summary>
            Gets the weight per access for this tier.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryAccess.TotalCost">
            <summary>
            Gets the total weighted cost as a complexity expression.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.MemoryAccess.Constant(ComplexityAnalysis.Core.Memory.MemoryTier,System.Double,System.String)">
            <summary>
            Creates a constant number of accesses to a tier.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.MemoryAccess.Linear(ComplexityAnalysis.Core.Memory.MemoryTier,ComplexityAnalysis.Core.Complexity.Variable,System.String)">
            <summary>
            Creates linear accesses to a tier: O(n) accesses.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.MemoryAccess.WithComplexity(ComplexityAnalysis.Core.Memory.MemoryTier,ComplexityAnalysis.Core.Complexity.ComplexityExpression,System.String)">
            <summary>
            Creates accesses with a given complexity expression.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Memory.AccessPattern">
            <summary>
            Represents a pattern of memory access behavior.
            Used to infer likely memory tier placement.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.AccessPattern.Sequential">
            <summary>
            Sequential access (e.g., array iteration) - cache-friendly.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.AccessPattern.Random">
            <summary>
            Random access (e.g., hash table lookup) - likely main memory.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.AccessPattern.TemporalLocality">
            <summary>
            Temporal locality - same data accessed multiple times.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.AccessPattern.SpatialLocality">
            <summary>
            Spatial locality - nearby data accessed together.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.AccessPattern.Strided">
            <summary>
            Strided access (e.g., matrix column traversal).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.AccessPattern.FileIO">
            <summary>
            File I/O access.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.AccessPattern.Network">
            <summary>
            Network access.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Memory.MemoryHierarchyCost">
            <summary>
            Aggregates multiple memory accesses into a hierarchical cost model.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryHierarchyCost.Accesses">
            <summary>
            All memory accesses in this cost model.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryHierarchyCost.TotalCost">
            <summary>
            Gets the total weighted cost as a complexity expression.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryHierarchyCost.DominantTier">
            <summary>
            Gets the dominant tier (the one contributing most to total cost).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryHierarchyCost.ByTier">
            <summary>
            Groups accesses by tier.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.MemoryHierarchyCost.Add(ComplexityAnalysis.Core.Memory.MemoryAccess)">
            <summary>
            Adds a memory access to this cost model.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.MemoryHierarchyCost.Combine(ComplexityAnalysis.Core.Memory.MemoryHierarchyCost)">
            <summary>
            Combines two memory hierarchy costs.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Memory.MemoryHierarchyCost.Empty">
            <summary>
            Creates an empty cost model.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.MemoryHierarchyCost.Single(ComplexityAnalysis.Core.Memory.MemoryAccess)">
            <summary>
            Creates a cost model with a single access.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Memory.MemoryTierEstimator">
            <summary>
            Heuristics for estimating memory tier from access patterns and data sizes.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemoryTierEstimator.L1CacheSize">
            <summary>
            Typical L1 cache size in bytes.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemoryTierEstimator.L2CacheSize">
            <summary>
            Typical L2 cache size in bytes.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Memory.MemoryTierEstimator.L3CacheSize">
            <summary>
            Typical L3 cache size in bytes.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.MemoryTierEstimator.EstimateTier(ComplexityAnalysis.Core.Memory.AccessPattern,System.Int64)">
            <summary>
            Estimates the memory tier based on access pattern and working set size.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Memory.MemoryTierEstimator.ConservativeEstimate(ComplexityAnalysis.Core.Memory.AccessPattern)">
            <summary>
            Conservative estimate: assumes main memory unless evidence suggests otherwise.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Progress.AnalysisPhase">
            <summary>
            The phases of complexity analysis.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.AnalysisPhase.StaticExtraction">
            <summary>
            Phase A: Static complexity extraction from AST/CFG.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.AnalysisPhase.RecurrenceSolving">
            <summary>
            Phase B: Solving recurrence relations.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.AnalysisPhase.Refinement">
            <summary>
            Phase C: Refinement via slack variables and perturbation.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.AnalysisPhase.SpeculativeAnalysis">
            <summary>
            Phase D: Speculative analysis for partial code.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.AnalysisPhase.Calibration">
            <summary>
            Phase E: Hardware calibration and weight adjustment.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Progress.IAnalysisProgress">
            <summary>
            Callback interface for receiving progress updates during complexity analysis.
            Enables real-time feedback, logging, and early termination detection.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Progress.IAnalysisProgress.OnPhaseStarted(ComplexityAnalysis.Core.Progress.AnalysisPhase)">
            <summary>
            Called when an analysis phase begins.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Progress.IAnalysisProgress.OnPhaseCompleted(ComplexityAnalysis.Core.Progress.AnalysisPhase,ComplexityAnalysis.Core.Progress.PhaseResult)">
            <summary>
            Called when an analysis phase completes.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Progress.IAnalysisProgress.OnMethodAnalyzed(ComplexityAnalysis.Core.Progress.MethodComplexityResult)">
            <summary>
            Called when a method's complexity has been analyzed.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Progress.IAnalysisProgress.OnIntermediateResult(ComplexityAnalysis.Core.Progress.PartialComplexityResult)">
            <summary>
            Called with intermediate results during analysis.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Progress.IAnalysisProgress.OnRecurrenceDetected(ComplexityAnalysis.Core.Progress.RecurrenceDetectionResult)">
            <summary>
            Called when a recurrence relation is detected.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Progress.IAnalysisProgress.OnRecurrenceSolved(ComplexityAnalysis.Core.Progress.RecurrenceSolutionResult)">
            <summary>
            Called when a recurrence relation has been solved.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Progress.IAnalysisProgress.OnWarning(ComplexityAnalysis.Core.Progress.AnalysisWarning)">
            <summary>
            Called when a warning or issue is encountered.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Progress.IAnalysisProgress.OnProgressUpdated(System.Double,System.String)">
            <summary>
            Called periodically with overall progress percentage.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Progress.PhaseResult">
            <summary>
            Result of a completed analysis phase.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.PhaseResult.Phase">
            <summary>
            The phase that completed.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.PhaseResult.Success">
            <summary>
            Whether the phase completed successfully.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.PhaseResult.Duration">
            <summary>
            Duration of the phase.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.PhaseResult.ItemsProcessed">
            <summary>
            Number of items processed in this phase.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.PhaseResult.ErrorMessage">
            <summary>
            Optional error message if the phase failed.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.PhaseResult.Metadata">
            <summary>
            Additional metadata about the phase result.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Progress.MethodComplexityResult">
            <summary>
            Result of analyzing a single method's complexity.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.MethodComplexityResult.MethodName">
            <summary>
            The fully qualified name of the method.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.MethodComplexityResult.FilePath">
            <summary>
            The file path containing the method.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.MethodComplexityResult.LineNumber">
            <summary>
            Line number where the method is defined.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.MethodComplexityResult.TimeComplexity">
            <summary>
            The computed time complexity.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.MethodComplexityResult.SpaceComplexity">
            <summary>
            The computed space complexity (if available).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.MethodComplexityResult.Confidence">
            <summary>
            Confidence level in the result (0.0 to 1.0).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.MethodComplexityResult.RequiresReview">
            <summary>
            Whether this result requires human review.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.MethodComplexityResult.ReviewReason">
            <summary>
            Reason for requiring review (if applicable).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Progress.PartialComplexityResult">
            <summary>
            Intermediate complexity result during analysis.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.PartialComplexityResult.Description">
            <summary>
            Description of what was analyzed.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.PartialComplexityResult.Complexity">
            <summary>
            The partial complexity expression.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.PartialComplexityResult.IsComplete">
            <summary>
            Whether this is a complete or partial result.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.PartialComplexityResult.Context">
            <summary>
            Context about where this result comes from.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Progress.RecurrenceDetectionResult">
            <summary>
            Result when a recurrence relation is detected.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.RecurrenceDetectionResult.MethodName">
            <summary>
            The method containing the recurrence.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.RecurrenceDetectionResult.Recurrence">
            <summary>
            The detected recurrence pattern.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.RecurrenceDetectionResult.Type">
            <summary>
            Type of recurrence detected.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.RecurrenceDetectionResult.IsSolvable">
            <summary>
            Whether this recurrence can be solved analytically.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.RecurrenceDetectionResult.RecommendedApproach">
            <summary>
            Recommended solving approach.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Progress.RecurrenceType">
            <summary>
            Types of recurrence relations.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.RecurrenceType.Linear">
            <summary>
            Linear recursion: T(n) = T(n-1) + f(n).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.RecurrenceType.DivideAndConquer">
            <summary>
            Divide and conquer: T(n) = a·T(n/b) + f(n).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.RecurrenceType.MultiTerm">
            <summary>
            Multi-term: T(n) = Σᵢ aᵢ·T(bᵢ·n) + f(n).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.RecurrenceType.Mutual">
            <summary>
            Mutual recursion between multiple functions.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.RecurrenceType.NonStandard">
            <summary>
            Non-standard recurrence requiring special handling.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Progress.SolvingApproach">
            <summary>
            Approaches for solving recurrence relations.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.SolvingApproach.MasterTheorem">
            <summary>
            Master Theorem for standard divide-and-conquer.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.SolvingApproach.AkraBazzi">
            <summary>
            Akra-Bazzi theorem for general multi-term recurrences.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.SolvingApproach.Expansion">
            <summary>
            Direct expansion/substitution.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.SolvingApproach.Numerical">
            <summary>
            Numerical approximation.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.SolvingApproach.Unsolvable">
            <summary>
            Cannot be solved analytically.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Progress.RecurrenceSolutionResult">
            <summary>
            Result of solving a recurrence relation.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.RecurrenceSolutionResult.Input">
            <summary>
            The input recurrence that was solved.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.RecurrenceSolutionResult.Solution">
            <summary>
            The closed-form solution.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.RecurrenceSolutionResult.ApproachUsed">
            <summary>
            The approach used to solve it.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.RecurrenceSolutionResult.Confidence">
            <summary>
            Confidence in the solution.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.RecurrenceSolutionResult.IsExact">
            <summary>
            Whether the solution is exact or an approximation.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.RecurrenceSolutionResult.Notes">
            <summary>
            Additional notes about the solution.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Progress.AnalysisWarning">
            <summary>
            Warning encountered during analysis.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.AnalysisWarning.Code">
            <summary>
            Unique warning code.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.AnalysisWarning.Message">
            <summary>
            Human-readable warning message.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.AnalysisWarning.Severity">
            <summary>
            Severity of the warning.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.AnalysisWarning.Location">
            <summary>
            Location in source code (if applicable).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Progress.AnalysisWarning.SuggestedAction">
            <summary>
            Suggested action to resolve the warning.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Progress.WarningSeverity">
            <summary>
            Severity levels for analysis warnings.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.WarningSeverity.Info">
            <summary>
            Informational message.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.WarningSeverity.Warning">
            <summary>
            Warning that may affect accuracy.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Progress.WarningSeverity.Error">
            <summary>
            Error that prevents accurate analysis.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Progress.NullAnalysisProgress">
            <summary>
            Null implementation of IAnalysisProgress that ignores all callbacks.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Progress.CompositeAnalysisProgress">
            <summary>
            Aggregates multiple progress handlers.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Progress.ConsoleAnalysisProgress">
            <summary>
            Logs progress to console output.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation">
            <summary>
            Represents a linear recurrence relation: T(n) = Σᵢ aᵢ·T(n-i) + f(n).
            </summary>
            <remarks>
            <para>
            <b>General Form:</b> T(n) = a₁T(n-1) + a₂T(n-2) + ... + aₖT(n-k) + f(n)
            </para>
            <para>
            where:
            </para>
            <list type="bullet">
              <item><description>aᵢ = coefficient for the (n-i)th term</description></item>
              <item><description>k = order of the recurrence (number of previous terms)</description></item>
              <item><description>f(n) = non-homogeneous term (driving function)</description></item>
            </list>
            
            <para>
            <b>Solution Method:</b> The characteristic polynomial method:
            </para>
            <list type="number">
              <item><description>
                Form characteristic polynomial: x^k - a₁x^(k-1) - a₂x^(k-2) - ... - aₖ = 0
              </description></item>
              <item><description>
                Find roots (may be real, repeated, or complex)
              </description></item>
              <item><description>
                Build general solution from roots
              </description></item>
              <item><description>
                Handle non-homogeneous term if present
              </description></item>
            </list>
            
            <para>
            <b>Complexity Implications:</b>
            </para>
            <list type="table">
              <listheader>
                <term>Root Type</term>
                <description>Solution Form</description>
              </listheader>
              <item>
                <term>Single root r > 1</term>
                <description>O(rⁿ) - exponential growth</description>
              </item>
              <item>
                <term>Single root r = 1 (with T(n-1))</term>
                <description>Summation: Σf(i)</description>
              </item>
              <item>
                <term>Repeated root r (multiplicity m)</term>
                <description>O(n^(m-1) · rⁿ) - polynomial times exponential</description>
              </item>
              <item>
                <term>Complex roots r·e^(iθ)</term>
                <description>Oscillatory: O(rⁿ) with periodic factor</description>
              </item>
            </list>
            
            <para>
            <b>Common Patterns:</b>
            </para>
            <code>
            // Fibonacci: T(n) = T(n-1) + T(n-2) → O(φⁿ) where φ ≈ 1.618
            var fib = LinearRecurrenceRelation.Create(new[] { 1.0, 1.0 }, O_1, n);
            
            // Linear summation: T(n) = T(n-1) + O(1) → O(n)
            var linear = LinearRecurrenceRelation.Create(new[] { 1.0 }, O_1, n);
            
            // Exponential doubling: T(n) = 2T(n-1) + O(1) → O(2ⁿ)
            var exp2 = LinearRecurrenceRelation.Create(new[] { 2.0 }, O_1, n);
            </code>
            </remarks>
            <seealso cref="T:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation"/>
            <seealso cref="T:ComplexityAnalysis.Core.Recurrence.RecurrenceComplexity"/>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation.Coefficients">
            <summary>
            The coefficients [a₁, a₂, ..., aₖ] for T(n-1), T(n-2), ..., T(n-k).
            </summary>
            <remarks>
            Coefficients[0] is the coefficient of T(n-1),
            Coefficients[1] is the coefficient of T(n-2), etc.
            </remarks>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation.NonRecursiveWork">
            <summary>
            The non-homogeneous (driving) function f(n) in T(n) = ... + f(n).
            </summary>
            <remarks>
            If the recurrence is homogeneous (no f(n) term), this should be
            <see cref="P:ComplexityAnalysis.Core.Complexity.ConstantComplexity.Zero"/>.
            </remarks>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation.Variable">
            <summary>
            The variable representing the input size (typically n).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation.Order">
            <summary>
            The order of the recurrence (k in T(n-k)).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation.IsHomogeneous">
            <summary>
            Whether this is a homogeneous recurrence (no f(n) term).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation.IsFirstOrder">
            <summary>
            Whether this is a first-order recurrence T(n) = a·T(n-1) + f(n).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation.IsSummation">
            <summary>
            Whether this is a simple summation T(n) = T(n-1) + f(n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation.Create(System.Double[],ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates a linear recurrence relation.
            </summary>
            <param name="coefficients">
            Coefficients [a₁, a₂, ..., aₖ] where T(n) = a₁T(n-1) + a₂T(n-2) + ... + f(n).
            </param>
            <param name="nonRecursiveWork">The non-homogeneous term f(n).</param>
            <param name="variable">The recurrence variable (typically n).</param>
            <returns>A new linear recurrence relation.</returns>
            <exception cref="T:System.ArgumentException">If coefficients is empty.</exception>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation.Create(System.Collections.Immutable.ImmutableArray{System.Double},ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates a linear recurrence relation with immutable coefficients.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation.Fibonacci(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates the Fibonacci recurrence: T(n) = T(n-1) + T(n-2) + f(n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation.Summation(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates a simple summation recurrence: T(n) = T(n-1) + f(n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation.Exponential(System.Double,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates an exponential recurrence: T(n) = a·T(n-1) + f(n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceRelation.ToString">
            <summary>
            Gets a human-readable representation of the recurrence.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceSolution">
            <summary>
            Result of solving a linear recurrence relation.
            </summary>
            <remarks>
            Contains both the asymptotic solution and details about how it was derived.
            </remarks>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceSolution.Solution">
            <summary>
            The closed-form asymptotic solution.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceSolution.Method">
            <summary>
            Description of the solution method used.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceSolution.Roots">
            <summary>
            The roots of the characteristic polynomial.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceSolution.DominantRoot">
            <summary>
            The dominant root (largest magnitude).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceSolution.HasPolynomialFactor">
            <summary>
            Whether the solution involves polynomial factors from repeated roots.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceSolution.Explanation">
            <summary>
            Detailed explanation of the solution derivation.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.CharacteristicRoot">
            <summary>
            A root of the characteristic polynomial with its properties.
            </summary>
            <remarks>
            Roots can be real or complex. Complex roots always come in conjugate pairs
            for recurrences with real coefficients.
            </remarks>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.CharacteristicRoot.RealPart">
            <summary>
            The real part of the root.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.CharacteristicRoot.ImaginaryPart">
            <summary>
            The imaginary part of the root (0 for real roots).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.CharacteristicRoot.Magnitude">
            <summary>
            The magnitude |r| = √(a² + b²) for complex root a + bi.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.CharacteristicRoot.Multiplicity">
            <summary>
            The multiplicity (how many times this root appears).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.CharacteristicRoot.IsReal">
            <summary>
            Whether this is a real root (imaginary part ≈ 0).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.CharacteristicRoot.IsRepeated">
            <summary>
            Whether this is a repeated root (multiplicity > 1).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.CharacteristicRoot.Real(System.Double,System.Int32)">
            <summary>
            Creates a real root.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.CharacteristicRoot.Complex(System.Double,System.Double,System.Int32)">
            <summary>
            Creates a complex root.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSystem">
            <summary>
            Represents a system of mutually recursive recurrence relations.
            
            For mutually recursive functions A(n) and B(n):
            - A(n) = T_A(n-1) + f_A(n) where A calls B
            - B(n) = T_B(n-1) + f_B(n) where B calls A
            
            This can be combined into a single recurrence by substitution.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSystem.Components">
            <summary>
            The methods involved in the mutual recursion cycle.
            The order represents the cycle: methods[0] → methods[1] → ... → methods[0]
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSystem.Variable">
            <summary>
            The recurrence variable (typically n).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSystem.CycleLength">
            <summary>
            Number of methods in the cycle.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSystem.CombinedReduction">
            <summary>
            The combined reduction per full cycle through all methods.
            For A → B → A with each doing -1, this is -2 (or scale 0.99^2 for divide pattern).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSystem.CombinedWork">
            <summary>
            The combined non-recursive work done in one full cycle.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSystem.ToSingleRecurrence">
            <summary>
            Converts the mutual recursion system to an equivalent single recurrence.
            
            For a cycle A → B → C → A where each reduces by 1:
            Combined: T(n) = T(n - cycleLength) + CombinedWork
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSystem.IsSubtractionPattern">
            <summary>
            Whether this is a subtraction-based mutual recursion (each step reduces by constant).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSystem.IsDivisionPattern">
            <summary>
            Whether this is a division-based mutual recursion (each step divides by constant).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSystem.GetDescription">
            <summary>
            Gets a human-readable description of the mutual recursion.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceComponent">
            <summary>
            Represents one method in a mutual recursion cycle.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceComponent.MethodName">
            <summary>
            The method name (for diagnostics).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceComponent.NonRecursiveWork">
            <summary>
            The non-recursive work done by this method.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceComponent.Reduction">
            <summary>
            How much the problem size is reduced when calling the next method.
            For subtraction: reduction amount (e.g., 1 for n-1).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceComponent.ScaleFactor">
            <summary>
            Scale factor for divide-style patterns (1/b in T(n/b)).
            For subtraction patterns, this is close to 1 (e.g., 0.99).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceComponent.Callees">
            <summary>
            The methods this component calls (within the cycle).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSolution">
            <summary>
            Result of solving a mutual recursion system.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSolution.Success">
            <summary>
            Whether the system was successfully solved.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSolution.Solution">
            <summary>
            The complexity solution for the first method in the cycle.
            Since all methods in the cycle have the same asymptotic complexity
            (differing only by constants), this applies to all.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSolution.MethodSolutions">
            <summary>
            Individual solutions for each method (may differ by constant factors).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSolution.Method">
            <summary>
            The approach used to solve the recurrence.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSolution.FailureReason">
            <summary>
            Diagnostic information if solving failed.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSolution.EquivalentRecurrence">
            <summary>
            The equivalent single recurrence that was solved.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSolution.Solved(ComplexityAnalysis.Core.Complexity.ComplexityExpression,System.String,ComplexityAnalysis.Core.Recurrence.RecurrenceRelation)">
            <summary>
            Creates a successful solution.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.MutualRecurrenceSolution.Failed(System.String)">
            <summary>
            Creates a failed solution.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.RecurrenceComplexity">
            <summary>
            Represents a recurrence relation for complexity analysis of recursive algorithms.
            </summary>
            <remarks>
            <para>
            <b>General Form:</b> T(n) = Σᵢ aᵢ·T(bᵢ·n + hᵢ(n)) + g(n)
            </para>
            <para>
            where:
            </para>
            <list type="bullet">
              <item><description>aᵢ = number of recursive calls of type i</description></item>
              <item><description>bᵢ = scale factor for subproblem size (0 &lt; bᵢ &lt; 1)</description></item>
              <item><description>hᵢ(n) = perturbation function (often 0)</description></item>
              <item><description>g(n) = non-recursive work at each level</description></item>
            </list>
            
            <para>
            <b>Analysis Theorems:</b>
            </para>
            <list type="table">
              <listheader>
                <term>Theorem</term>
                <description>Applicability</description>
              </listheader>
              <item>
                <term>Master Theorem</term>
                <description>Single-term: T(n) = a·T(n/b) + f(n), where a ≥ 1, b > 1</description>
              </item>
              <item>
                <term>Akra-Bazzi</term>
                <description>Multi-term: T(n) = Σᵢ aᵢ·T(bᵢn) + g(n), where aᵢ > 0, 0 &lt; bᵢ &lt; 1</description>
              </item>
              <item>
                <term>Linear Recurrence</term>
                <description>T(n) = T(n-1) + f(n), solved by summation</description>
              </item>
            </list>
            
            <para>
            <b>Common Patterns:</b>
            </para>
            <code>
            // Merge Sort: T(n) = 2T(n/2) + O(n) → O(n log n)
            var mergeSort = RecurrenceComplexity.DivideAndConquer(2, 2, O_n, n);
            
            // Binary Search: T(n) = T(n/2) + O(1) → O(log n)
            var binarySearch = RecurrenceComplexity.DivideAndConquer(1, 2, O_1, n);
            
            // Strassen: T(n) = 7T(n/2) + O(n²) → O(n^2.807)
            var strassen = RecurrenceComplexity.DivideAndConquer(7, 2, O_n2, n);
            </code>
            
            <para>
            See the TheoremApplicabilityAnalyzer in ComplexityAnalysis.Solver for the analysis engine
            that solves these recurrences.
            </para>
            </remarks>
            <seealso cref="T:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation"/>
            <seealso cref="T:ComplexityAnalysis.Core.Recurrence.RecurrenceTerm"/>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.RecurrenceComplexity.#ctor(System.Collections.Immutable.ImmutableList{ComplexityAnalysis.Core.Recurrence.RecurrenceTerm},ComplexityAnalysis.Core.Complexity.Variable,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Represents a recurrence relation for complexity analysis of recursive algorithms.
            </summary>
            <remarks>
            <para>
            <b>General Form:</b> T(n) = Σᵢ aᵢ·T(bᵢ·n + hᵢ(n)) + g(n)
            </para>
            <para>
            where:
            </para>
            <list type="bullet">
              <item><description>aᵢ = number of recursive calls of type i</description></item>
              <item><description>bᵢ = scale factor for subproblem size (0 &lt; bᵢ &lt; 1)</description></item>
              <item><description>hᵢ(n) = perturbation function (often 0)</description></item>
              <item><description>g(n) = non-recursive work at each level</description></item>
            </list>
            
            <para>
            <b>Analysis Theorems:</b>
            </para>
            <list type="table">
              <listheader>
                <term>Theorem</term>
                <description>Applicability</description>
              </listheader>
              <item>
                <term>Master Theorem</term>
                <description>Single-term: T(n) = a·T(n/b) + f(n), where a ≥ 1, b > 1</description>
              </item>
              <item>
                <term>Akra-Bazzi</term>
                <description>Multi-term: T(n) = Σᵢ aᵢ·T(bᵢn) + g(n), where aᵢ > 0, 0 &lt; bᵢ &lt; 1</description>
              </item>
              <item>
                <term>Linear Recurrence</term>
                <description>T(n) = T(n-1) + f(n), solved by summation</description>
              </item>
            </list>
            
            <para>
            <b>Common Patterns:</b>
            </para>
            <code>
            // Merge Sort: T(n) = 2T(n/2) + O(n) → O(n log n)
            var mergeSort = RecurrenceComplexity.DivideAndConquer(2, 2, O_n, n);
            
            // Binary Search: T(n) = T(n/2) + O(1) → O(log n)
            var binarySearch = RecurrenceComplexity.DivideAndConquer(1, 2, O_1, n);
            
            // Strassen: T(n) = 7T(n/2) + O(n²) → O(n^2.807)
            var strassen = RecurrenceComplexity.DivideAndConquer(7, 2, O_n2, n);
            </code>
            
            <para>
            See the TheoremApplicabilityAnalyzer in ComplexityAnalysis.Solver for the analysis engine
            that solves these recurrences.
            </para>
            </remarks>
            <seealso cref="T:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation"/>
            <seealso cref="T:ComplexityAnalysis.Core.Recurrence.RecurrenceTerm"/>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.RecurrenceComplexity.TotalRecursiveCalls">
            <summary>
            Gets the total number of recursive calls (sum of coefficients).
            For T(n) = 2T(n/2) + O(n), this returns 2.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.RecurrenceComplexity.FitsMasterTheorem">
            <summary>
            Determines if this recurrence fits the Master Theorem pattern:
            T(n) = a·T(n/b) + f(n) where a ≥ 1, b > 1.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.RecurrenceComplexity.FitsAkraBazzi">
            <summary>
            Determines if this recurrence fits the Akra-Bazzi pattern
            (more general than Master Theorem).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.RecurrenceComplexity.DivideAndConquer(System.Double,System.Double,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates a standard divide-and-conquer recurrence: T(n) = a·T(n/b) + O(n^d).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.RecurrenceComplexity.Linear(ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates a linear recursion: T(n) = T(n-1) + O(f(n)).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.RecurrenceTerm">
            <summary>
            Represents a single term in a recurrence relation.
            </summary>
            <remarks>
            <para>
            For a recurrence like T(n) = 2·T(n/3) + O(n), the term is:
            </para>
            <list type="bullet">
              <item><description><see cref="P:ComplexityAnalysis.Core.Recurrence.RecurrenceTerm.Coefficient"/> = 2 (number of recursive calls)</description></item>
              <item><description><see cref="P:ComplexityAnalysis.Core.Recurrence.RecurrenceTerm.Argument"/> = n/3 (subproblem size expression)</description></item>
              <item><description><see cref="P:ComplexityAnalysis.Core.Recurrence.RecurrenceTerm.ScaleFactor"/> = 1/3 (reduction ratio)</description></item>
            </list>
            <para>
            <b>Well-formedness:</b> For theorem applicability, terms must satisfy:
            </para>
            <list type="bullet">
              <item><description>Coefficient > 0 (at least one recursive call)</description></item>
              <item><description>0 &lt; ScaleFactor &lt; 1 (subproblem is smaller)</description></item>
            </list>
            </remarks>
            <param name="Coefficient">The multiplier for this recursive call (a in a·T(f(n))).</param>
            <param name="Argument">The argument to the recursive call (f(n) in T(f(n))).</param>
            <param name="ScaleFactor">The scale factor for the subproblem size (1/b in T(n/b)).</param>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.RecurrenceTerm.#ctor(System.Double,ComplexityAnalysis.Core.Complexity.ComplexityExpression,System.Double)">
            <summary>
            Represents a single term in a recurrence relation.
            </summary>
            <remarks>
            <para>
            For a recurrence like T(n) = 2·T(n/3) + O(n), the term is:
            </para>
            <list type="bullet">
              <item><description><see cref="P:ComplexityAnalysis.Core.Recurrence.RecurrenceTerm.Coefficient"/> = 2 (number of recursive calls)</description></item>
              <item><description><see cref="P:ComplexityAnalysis.Core.Recurrence.RecurrenceTerm.Argument"/> = n/3 (subproblem size expression)</description></item>
              <item><description><see cref="P:ComplexityAnalysis.Core.Recurrence.RecurrenceTerm.ScaleFactor"/> = 1/3 (reduction ratio)</description></item>
            </list>
            <para>
            <b>Well-formedness:</b> For theorem applicability, terms must satisfy:
            </para>
            <list type="bullet">
              <item><description>Coefficient > 0 (at least one recursive call)</description></item>
              <item><description>0 &lt; ScaleFactor &lt; 1 (subproblem is smaller)</description></item>
            </list>
            </remarks>
            <param name="Coefficient">The multiplier for this recursive call (a in a·T(f(n))).</param>
            <param name="Argument">The argument to the recursive call (f(n) in T(f(n))).</param>
            <param name="ScaleFactor">The scale factor for the subproblem size (1/b in T(n/b)).</param>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.RecurrenceTerm.Coefficient">
            <summary>The multiplier for this recursive call (a in a·T(f(n))).</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.RecurrenceTerm.Argument">
            <summary>The argument to the recursive call (f(n) in T(f(n))).</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.RecurrenceTerm.ScaleFactor">
            <summary>The scale factor for the subproblem size (1/b in T(n/b)).</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.RecurrenceTerm.IsReducing">
            <summary>
            Determines if this term represents a proper reduction (subproblem smaller than original).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.RecurrenceRelationTerm">
            <summary>
            A term in a recurrence relation with coefficient and scale factor.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.RecurrenceRelationTerm.#ctor(System.Double,System.Double)">
            <summary>
            A term in a recurrence relation with coefficient and scale factor.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation">
            <summary>
            Represents a fully specified recurrence relation with explicit terms for analysis.
            </summary>
            <remarks>
            <para>
            This is the normalized form used as input to recurrence solvers. It extracts the
            essential mathematical components from <see cref="T:ComplexityAnalysis.Core.Recurrence.RecurrenceComplexity"/>:
            </para>
            <list type="bullet">
              <item><description><see cref="P:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation.Terms"/>: The recursive structure [(aᵢ, bᵢ)]</description></item>
              <item><description><see cref="P:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation.NonRecursiveWork"/>: The g(n) function</description></item>
              <item><description><see cref="P:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation.BaseCase"/>: The T(1) boundary condition</description></item>
            </list>
            
            <para>
            <b>Theorem Selection:</b>
            </para>
            <list type="bullet">
              <item><description>
                <see cref="P:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation.FitsMasterTheorem"/>: Single term with a ≥ 1, b > 1
              </description></item>
              <item><description>
                <see cref="P:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation.FitsAkraBazzi"/>: All terms have aᵢ > 0 and 0 &lt; bᵢ &lt; 1
              </description></item>
            </list>
            
            <para>
            <b>Convenience Factories:</b>
            </para>
            <code>
            // Standard divide-and-conquer
            var rec = RecurrenceRelation.DivideAndConquer(2, 2, O_n, Variable.N);
            
            // From existing RecurrenceComplexity
            var rel = RecurrenceRelation.FromComplexity(recurrence);
            </code>
            </remarks>
            <seealso cref="T:ComplexityAnalysis.Core.Recurrence.RecurrenceComplexity"/>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation.Terms">
            <summary>
            The recursive terms: [(aᵢ, bᵢ)] where T(n) contains aᵢ·T(bᵢ·n).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation.NonRecursiveWork">
            <summary>
            The non-recursive work function g(n).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation.BaseCase">
            <summary>
            The base case complexity T(1).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation.Variable">
            <summary>
            The recurrence variable (typically n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation.#ctor(System.Collections.Generic.IEnumerable{ComplexityAnalysis.Core.Recurrence.RecurrenceRelationTerm},ComplexityAnalysis.Core.Complexity.Variable,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Creates a recurrence relation from explicit terms.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation.FitsMasterTheorem">
            <summary>
            Checks if this recurrence fits the Master Theorem form.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation.FitsAkraBazzi">
            <summary>
            Checks if this recurrence fits the Akra-Bazzi pattern.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation.A">
            <summary>
            For Master Theorem: a in T(n) = a·T(n/b) + f(n).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation.B">
            <summary>
            For Master Theorem: b in T(n) = a·T(n/b) + f(n).
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation.FromComplexity(ComplexityAnalysis.Core.Recurrence.RecurrenceComplexity)">
            <summary>
            Creates a RecurrenceRelation from a RecurrenceComplexity.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.RecurrenceRelation.DivideAndConquer(System.Double,System.Double,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.Variable)">
            <summary>
            Creates a standard divide-and-conquer recurrence: T(n) = a·T(n/b) + f(n).
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.TheoremApplicability">
            <summary>
            Base type for theorem applicability results.
            Captures which theorem applies (or not) and all relevant parameters.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.TheoremApplicability.IsApplicable">
            <summary>Whether any theorem successfully applies.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.TheoremApplicability.Solution">
            <summary>The recommended solution if applicable.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.TheoremApplicability.Explanation">
            <summary>Human-readable explanation of the result.</summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.MasterTheoremApplicable">
            <summary>
            Master Theorem applies successfully.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.MasterTheoremApplicable.#ctor(ComplexityAnalysis.Core.Recurrence.MasterTheoremCase,System.Double,System.Double,System.Double,ComplexityAnalysis.Core.Complexity.ExpressionClassification,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Master Theorem applies successfully.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MasterTheoremApplicable.Epsilon">
            <summary>
            For Case 1: the ε such that f(n) = O(n^(log_b(a) - ε)).
            For Case 3: the ε such that f(n) = Ω(n^(log_b(a) + ε)).
            For Case 2: 0 (exact match).
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MasterTheoremApplicable.LogExponentK">
            <summary>For Case 2: the k in f(n) = Θ(n^d · log^k n).</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.MasterTheoremApplicable.RegularityVerified">
            <summary>For Case 3: whether the regularity condition was verified.</summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.MasterTheoremCase">
            <summary>
            The three cases of the Master Theorem.
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Recurrence.MasterTheoremCase.Case1">
            <summary>
            f(n) = O(n^(log_b(a) - ε)) for some ε > 0.
            Work at leaves dominates. Solution: Θ(n^(log_b a)).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Recurrence.MasterTheoremCase.Case2">
            <summary>
            f(n) = Θ(n^(log_b a) · log^k n) for some k ≥ 0.
            Work balanced across levels. Solution: Θ(n^(log_b a) · log^(k+1) n).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Recurrence.MasterTheoremCase.Case3">
            <summary>
            f(n) = Ω(n^(log_b(a) + ε)) for some ε > 0, AND regularity holds.
            Work at root dominates. Solution: Θ(f(n)).
            </summary>
        </member>
        <member name="F:ComplexityAnalysis.Core.Recurrence.MasterTheoremCase.Gap">
            <summary>
            Falls between cases (Master Theorem gap).
            Use Akra-Bazzi or other methods.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.AkraBazziApplicable">
            <summary>
            Akra-Bazzi Theorem applies successfully.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.AkraBazziApplicable.#ctor(System.Double,ComplexityAnalysis.Core.Complexity.ComplexityExpression,ComplexityAnalysis.Core.Complexity.ComplexityExpression)">
            <summary>
            Akra-Bazzi Theorem applies successfully.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.AkraBazziApplicable.Terms">
            <summary>The recurrence terms used.</summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.AkraBazziApplicable.GClassification">
            <summary>Classification of g(n).</summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceSolved">
            <summary>
            Linear recurrence T(n) = T(n-1) + f(n) solved directly.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.LinearRecurrenceSolved.#ctor(ComplexityAnalysis.Core.Complexity.ComplexityExpression,System.String)">
            <summary>
            Linear recurrence T(n) = T(n-1) + f(n) solved directly.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.TheoremNotApplicable">
            <summary>
            No standard theorem applies.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.TheoremNotApplicable.#ctor(System.String,System.Collections.Immutable.ImmutableList{System.String})">
            <summary>
            No standard theorem applies.
            </summary>
        </member>
        <member name="P:ComplexityAnalysis.Core.Recurrence.TheoremNotApplicable.Suggestions">
            <summary>Suggested alternative approaches.</summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.ITheoremApplicabilityAnalyzer">
            <summary>
            Analyzer that determines which theorem applies to a recurrence.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.ITheoremApplicabilityAnalyzer.Analyze(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation)">
            <summary>
            Analyzes a recurrence and determines which theorem applies.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.ITheoremApplicabilityAnalyzer.CheckMasterTheorem(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation)">
            <summary>
            Specifically checks Master Theorem applicability.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.ITheoremApplicabilityAnalyzer.CheckAkraBazzi(ComplexityAnalysis.Core.Recurrence.RecurrenceRelation)">
            <summary>
            Specifically checks Akra-Bazzi applicability.
            </summary>
        </member>
        <member name="T:ComplexityAnalysis.Core.Recurrence.TheoremApplicabilityExtensions">
            <summary>
            Extension methods for working with theorem applicability.
            </summary>
        </member>
        <member name="M:ComplexityAnalysis.Core.Recurrence.TheoremApplicabilityExtensions.AnalyzeRecurrence(ComplexityAnalysis.Core.Recurrence.RecurrenceComplexity,ComplexityAnalysis.Core.Recurrence.ITheoremApplicabilityAnalyzer)">
            <summary>
            Tries Master Theorem first, then Akra-Bazzi, then reports failure.
            </summary>
        </member>
    </members>
</doc>
